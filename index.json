[{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet.","tags":null,"title":"","type":"authors"},{"authors":["jsalwan"],"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"f7d75d23e074d3b0d763a61212d95b47","permalink":"/authors/jsalwan/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/jsalwan/","section":"authors","summary":"","tags":null,"title":"","type":"authors"},{"authors":["pteuwen"],"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"eec0f57985bc35d96e9bd7774db521e6","permalink":"/authors/pteuwen/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/pteuwen/","section":"authors","summary":"","tags":null,"title":"","type":"authors"},{"authors":["romain"],"categories":null,"content":"Security Engineer.\nWorking on the development of new tools to assist security researchers, I\u0026rsquo;m also interested in Android, (de)obfuscation and software protections.\nAuthor of LIEF\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"bb894883124d67bb607931430a503f89","permalink":"/authors/romain/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/romain/","section":"authors","summary":"Security Engineer.\nWorking on the development of new tools to assist security researchers, I\u0026rsquo;m also interested in Android, (de)obfuscation and software protections.\nAuthor of LIEF","tags":null,"title":"","type":"authors"},{"authors":["Romain Thomas"],"categories":["iOS","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; font-size: 87.5%; } .blue { color: blue; font-family: 'Fira Code', monospace; font-size: 87.5%; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; font-size: 87.5%; } .red { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; font-size: 87.5%; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; font-size: 87.5%; }   Do not expect a click \u0026amp; play solution for PokemonGO in this blog post. This blog post is more about the technical aspects of jailbreak detection than a bypass for this game.   Introduction While working on LIEF during my vacations to support in-memory parsing for Mach-O files, I found that PokemonGO was an interesting use case to introduce this feature. It led me to look at the jailbreak and Frida detection implemented in this game. Being more familiar with Android than iOS, the analysis workflow on this platform is quite different, which is also a good opportunity to improve tooling.\nThe first challenge stems from jailbreaking the device. Fortunately, checkra1n eases this step. The second difficulty lies in extracting the encrypted iOS app from the device. In contrast to Android, iOS apps are encrypted on the disk and decrypted by the kernel when loaded. It means that one way to get the unencrypted code is to dump the file from memory. One could also leverage the function mremap_encrypted() as described in Decrypting Apps on iOS.\nPokemonGO Overview When running PokemonGO on a jailbroken device1, the application immediately crashes with the following backtrace:\n0 ??? 0x000000020ac46ab8 0 + 8770579128 1 libdyld.dylib 0x0000000184df8304 invocation function for block in dyld3::AllImages::runAllInitializersInImage(dyld3::closure::Image const*, dyld3::MachOLoaded const*) + 136 2 libdyld.dylib 0x0000000184dea5b0 dyld3::closure::Image::forEachInitializer(void const*, void (void const*) block_pointer) const + 96 3 libdyld.dylib 0x0000000184df8160 invocation function for block in dyld3::AllImages::runInitialzersBottomUp(dyld3::closure::Image const*) + 296 4 libdyld.dylib 0x0000000184deae6c dyld3::closure::Image::forEachImageToInitBefore(void (unsigned int, bool\u0026amp;) block_pointer) const + 92 5 libdyld.dylib 0x0000000184df8b48 dyld3::AllImages::loadImage(Diagnostics\u0026amp;, char const*, unsigned int, dyld3::closure::DlopenClosure const*, bool, bool, bool, bool, void const*) + 776 6 libdyld.dylib 0x0000000184df8698 dyld3::AllImages::dlopen(Diagnostics\u0026amp;, char const*, bool, bool, bool, bool, bool, void const*, bool) + 872 7 libdyld.dylib 0x0000000184dfa2b4 dyld3::dlopen_internal(char const*, int, void*) + 368 8 libdyld.dylib 0x0000000184ded5b0 dlopen_internal(char const*, int, void*) + 108 9 CoreFoundation 0x00000001850ed038 _CFBundleDlfcnLoadFramework + 136 10 CoreFoundation 0x00000001850be974 _CFBundleLoadExecutableAndReturnError + 376 11 Foundation 0x0000000186359ba8 -[NSBundle loadAndReturnError:] + 332 12 pokemongo 0x00000001041a7c5c 0x1041a0000 + 31836 13 pokemongo 0x00000001041a7d50 0x1041a0000 + 32080 14 libdyld.dylib 0x0000000184de9588 start + 4  The full crash log is available here.   In this backtrace, the main pokemongo binary is a kind of stub that loads the Unity binary: UnityFramework which contains the main logic of the game.\nThis library is loaded by the dlopen_internal function at index 8 in the backtrace as a result of -[NSBundle loadAndReturnError:]. Since UnityFramework depends on other libraries, they are (pre)loaded with Image::forEachImageToInitBefore which processes the following files:\n @/usr/lib/libc++.1.dylib \u0026hellip; @rpath/NianticLabsPlugin.framework/NianticLabsPlugin \u0026hellip; @rpath/libswiftos.dylib  Among those dependencies, we can notice the NianticLabsPlugin library which is a cross-platform Unity plugin \u0026ndash; also present in the Android version \u0026ndash; that contains the main protections of the game. These protections are used to prevent cheat, bots, GPS spoofing, in PokemonGO. The whole being obfuscated by Digital.ai (formerly known as Arxan). NianticLabsPlugin communicates with the UnityFramework through an exported function GetN2Api that returns an array of functions (pointers).\nThe following figure outlines these different components:\nGetting back to the backtrace, if we assume that the application crashes when loading NianticLabsPlugin, it precisely crashes when calling the Mach-O constructors in AllImages::runAllInitializersInImage. Since the application is heavily obfuscated, a static analysis reaches quickly its limits, which forces us to emulate or dynamically analyze the functions of interest.\n The addresses of the functions/instructions mentioned in this blog post are based on the following version of NianticLabsPlugin:\n NianticLabsPlugin - 2140426ccdfdfb2529f454697cb5cc83\n PokemonGO v0.211.2 - June 2021\n  Analyzing Mach-O constructors with Frida From the previous section, we surmised that the application crashed because of the NianticLabsPlugin\u0026rsquo;s constructors. Since these functions are called before any other functions of the library, it raises the question of finding a way to perform actions (or hook) before they are executed.\nOn Android, when we need to analyse a library\u0026rsquo;s constructors, we can hook the call_array function from Bionic\u0026rsquo;s linker (ELF loader):\n If we try to apply the same approach on iOS, the mirror of the ELF loader on iOS is dyld which contains most of the logic to load Mach-O files. It turns out that at some points, the Mach-O\u0026rsquo;s constructors are processed in the doModInitFunctions function (from ImageLoaderMachO.cpp).\nvoid ImageLoaderMachO::doModInitFunctions(const LinkContext\u0026amp; context) { ... for (const struct macho_section* sect=sectionsStart; sect \u0026lt; sectionsEnd; ++sect) { const uint8_t type = sect-\u0026gt;flags \u0026amp; SECTION_TYPE; if ( type == S_MOD_INIT_FUNC_POINTERS ) { Initializer* inits = (Initializer*)(sect-\u0026gt;addr + fSlide); ... if (!this-\u0026gt;containsAddress(stripPointer((void*)func)) ) { dyld::throwf(\u0026#34;initializer function %p not in mapped image for %s\\n\u0026#34;, func, this-\u0026gt;getPath()); } ... func(context.argc, context.argv, context.envp, context.apple, \u0026amp;context.programVars); } } ... } From this code, we can notice that all constructor addresses are checked beforehand by the containsAddress function. Therefore, it makes this function a good hooking spot as it is executed before calling the constructor itself. One can use the native SDK of frida-gum to perform this action:\n// Address of ImageLoader::containsAddress in /usr/lib/dyld const uintptr_t containsAddress_ptr = ...; // Setup hooks with gum_interceptor_attach GumAttachReturn attach_ret = gum_interceptor_attach( listener_-\u0026gt;interceptor, /* target */ reinterpret_cast\u0026lt;void*\u0026gt;(containsAddress_ptr), reinterpret_cast\u0026lt;GumInvocationListener*\u0026gt;(listener_), /* ID */ reinterpret_cast\u0026lt;void*\u0026gt;(containsAddress_ptr) ); .... // Equivalent of onEnter in Javascript void native_listener_on_enter(GumInvocationListener* listener, GumInvocationContext* ic) { const uintptr_t ctor_function_addr = ic-\u0026gt;cpu_context-\u0026gt;x[1]; // Do stuff with ctor_function_addr }  containsAddress is a member function, therefore x0 contains a pointer on this and the address to check is located in x1.   By hooking containsAddress(), we get the control before the execution of the constructors. It gives us the ability to perform the following actions that can help to identify the constructor involved in the crash:\n Trace the constructors (see: constructors_trace.log) Replace/disable a constructor (gum_interceptor_replace) Detect the first constructor and hook the next ones (gum_interceptor_attach)  NianticLabsPlugin embeds no less than 120 constructors among those, 62 are involved in detecting Frida, jailbroken devices, anti-debug, etc:\n   Index Offset Description     15 0x4369e0 Anti-debug \u0026amp; anti-emulation   16 0x00e0d8 Frida detection   17 0x26bd5c Anti-bypass?   18 0x449b84 Anti-jailbreak, anti-Frida   19 0x731b90 Anti-jailbreak, anti-debug, anti-frida   20 0x359194 Anti-jailbreak    Once we reduced the set of functions involved in the crash, we can combine dynamic analysis with Frida and emulation with Unicorn.\nAnti-debug One of the redundant checks we can find in many functions (not only the constructors) are the anti-debugs. They always come in two parts:\n Try to \u0026ldquo;kill\u0026rdquo; its own pid with the 0-signal Check if PTRACE is flagged  void try_kill() { const int pid = getpid(); // syscall@0x436cdc  int ret = kill(pid, 0); // syscall@0x436d28 } According to the man page of kill (man 2 kill), the signal 0 is used to check that the pid given in the first parameter really exists.\n [\u0026hellip;] A value of 0, however, will cause error checking to be performed (with no signal being sent). This can be used to check the validity of pid.\n This kill operation is followed by three PTRACE checks:\n// Done three times inline bool ptrace_detect() { int32_t opt[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid(), }; kinfo_proc info; sysctl(opt, 4, \u0026amp;info, sizeof(kinfo_proc), nullptr, 0); return info.kp_proc.p_flag \u0026amp; P_TRACED; } These three P_TRACED checks always come together:\n0x436cdc: getpid(): 6015 0x436d28: kill(6015, 0): 0 0x4374b0: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) 0x4371e8: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) 0x437398: sysctl(CTL_KERN, KERN_PROC, KERN_PROC_PID, 6015) Frida Detection Frida is detected by the application through its client-server mode, which binds the localhost on the port 27042. When PokemonGO is starting, it tries to open a socket on this port and if it manages to connect, it tests the Frida handshake.\n0x00e3b8: getifaddrs(0x16b7fb518): 0x0 0x016990: socket(\u0026#39;IPV4\u0026#39;, \u0026#39;TCP\u0026#39;, \u0026#39;0\u0026#39;): 0x8 0x019d60: bind(\u0026#39;PF_INET\u0026#39;, 0x8, \u0026#39;127.0.0.1:27042\u0026#39;) 0x01805c: close(0x8) 0x016990: socket(\u0026#39;IPV4\u0026#39;, \u0026#39;TCP\u0026#39;, \u0026#39;0\u0026#39;): 0x8 0x019d60: bind(\u0026#39;PF_INET\u0026#39;, 0x8, \u0026#39;192.168.0.26:27042\u0026#39;) 0x01805c: close(0x8) 0x00e3ec: freeifaddrs(0x10601ac00): 0x105360a00 The application also iterates over the list of the libraries loaded in memory with the _dyld_image_count/_dyld_get_image_name functions. Nevertheless, it seems that they are not used to detect Frida libraries artifacts (like FridaGadget.dylib).\nJailbreak Detection The application implements jailbreak detection by checking if some files are accessible or not on the device. Most of the checks are done by using the access() syscalls that are inlined in different places:\n0x44c390: access(\u0026#39;/bin/grep\u0026#39;, 0x0) ... 0x7326b0: access(\u0026#39;/private/var/checkra1n.dmg\u0026#39;, 0x0) The list of the checked files is given in the annexes of the blog post.\n This list is very close to vnodebypass/hidePathList.plist   In addition to raw access syscall, the application enhances its detection by creating a symbolic link of the root directory in a temporary app data directory:\n0x734e08: symlink('/Applications/..', '/private/var/mobile/Containers/Data/Application/D933FBC9-90E7-4584-851E-CE2D5E900446/tmp/WCH38bnM0x101a9e7d0') Then, it performs the same checks with the app data directory as prefix: [...]/tmp/WCH38bnM0x101a9e7d0:\n0x7376d8: access('/private/var/mobile/Containers/Data/Application/D933FBC9-90E7-4584-851E-CE2D5E900446/tmp/3Odis0x101a9dfd0/usr/bin/passwd', 0x0) Signature Check At some point, one function checks the integrity of the signature of the pokemongo binary. This check starts by opening the main pokemongo binary from the disk:\n0x7392ec: add x0, x19, #6,lsl#12 0x7392f0: add x0, x0, #0x540 0x7392f4: mov w1, #0x1000000 0x7392f8: mov x2, #0 0x7392fc: svc 0x80 ; x16 -\u0026gt; SYS_open = 5 // open(\u0026#39;/private/var/containers/Bundle/Application/[...]/pokemongo.app/pokemongo\u0026#39;): fd_pgo Then, it reads the beginning of the file in a stack buffer:\n0x74b494: ldr x0, [x19, #0xc0] ; fd 0x74b498: ldr x1, [x19, #0x130] ; buff 0x74b49c: ldr x2, [x19, #0xb8] ; buff_size 0x74b4a0: svc 0x80 ; x16 -\u0026gt; SYS_read = 3 // uint8_t macho_head[0x4167]; // 0x74b4a0: read(fd_pgo, macho_header, 0x4167); to iterate over the Mach-O load commands:\n; x8 points to the read\u0026#39;s buffer 0x73942c: ldr w8, [x8, #0x10] ; Number of LC_COMMANDS for (size_t i = 0; i \u0026lt; nb_cmds; ++i) { 0x74bc40: ldr w10, [x9, #4] ; Command\u0026#39;s size 0x74ade4: ldr w9, [x9] ; command\u0026#39;s type if (cmd.type == LC_CODE_SIGNATURE) { 0x74b1b8: ldr w10, [x10, #8] ; read signature offset -\u0026gt; 0xc3d0 } } With the offset of the Mach-O LC_CODE_SIGNATURE command, it reads the raw signature using the lseek/read syscalls:\nuint8_t sig_header[0x205]; 0x73a978: lseek(fd_pgo, LC_CODE_SIGNATURE offset, 0x0) 0x73aecc: read(fd_pgo, \u0026amp;sig_header, 0x205); The raw signature buffer is processed by chunks of 10 bytes in a function that looks like a checksum:\n[...] 0x73ad58: ldrsb w13, [x12] 0x73ad5c: mov w14, #83 0x73ad60: sub w13, w14, w13 0x73ad64: ldrsb w14, [x12, #1] 0x73ad68: mov w15, #87 0x73ad6c: sub w14, w15, w14 0x73ad70: ldrsb w16, [x12, #2] 0x73ad74: mov w17, #53 0x73ad78: sub w16, w17, w16 0x73ad7c: ldrsb w17, [x12, #3] 0x73ad80: mov w0, #52 0x73ad84: sub w17, w0, w17 0x73ad88: ldrsb w0, [x12, #4] 0x73ad8c: sub w0, w15, w0 0x73ad90: ldrsb w1, [x12, #5] 0x73ad94: mov w2, #51 0x73ad98: sub w1, w2, w1 0x73ad9c: ldrsb w2, [x12, #6] 0x73ada0: mov w3, #54 0x73ada4: sub w2, w3, w2 0x73ada8: ldrsb w3, [x12, #7] 0x73adac: sub w15, w15, w3 0x73adb0: ldrsb w3, [x12, #8] 0x73adb4: mov w4, #78 0x73adb8: sub w3, w4, w3 0x73adbc: ldrsb w12, [x12, #9] 0x73adc0: mov w4, #70 0x73adc4: sub w4, w4, w12 [...] I did not manage to identify the underlying checksum algorithm, but it involves square multiplications and the key(?): SW5436NF\nControl-Fault Injection Once we determined the functions involved in the detections, we might want to disable them in order to run the game smoothly. Actually, PokemonGO is protected against such bypass with global variables that assert if a function ran successfully or not.\nThis protection is equivalent to the following piece of code:\nstatic constexpr uintptr_t GOOD = 0x00627178; // bqx ? static uintptr_t MAGIC_CFI = 0xdeadc0de; __attribute__((constructor)) void frida_detect() { if (is_frida_running()) { crash(); } MAGIC_CFI = GOOD; } __attribute__((constructor)) void control_fault_check() { if (MAGIC_CFI != GOOD) { crash(); } } If we only disable frida_detect(), the application will crash because of control_fault_check().\nWe could bypass this protection by identifying the address of the MAGIC_CFI in the __data section, or by disabling the control_fault_check().\nWhat about LIEF? As mentioned in the introduction, it started with an ongoing feature to parse Mach-O files from memory. Basically, LIEF will3 enable to parse Mach-O files4 from an absolute address with this kind of API:\n// 0x10234400 -\u0026gt; start of the Mach-O file auto bin = LIEF::MachO::Parser::parse_from_memory(0x10234400); Depending on the user\u0026rsquo;s needs, the write() operation will optionally undo all the relocations and the symbol bindings. This could be useful if we aim at (re)running the file dumped (on a Apple M1?).\nAs expected, the strings used within the NianticLabsPlugin library are encoded by the obfuscator. We could statically analyze the decoding routine (cf. Tim Blazytko\u0026rsquo;s blog post) ,but another technique consists in using a property of the obfuscator\u0026rsquo;s string encoding mechanism.\nIt seems that the obfuscator put all the strings5 in the data section and decrypts all of them in a single constructor function.\nFor instance, if we have the string \u0026ldquo;TOKEN\u0026rdquo; to protect in the following functions:\nvoid protect_me() { sensitive(\u0026#34;TOKEN\u0026#34;); } void protect_me_2() { sensitive(\u0026#34;TOKEN2\u0026#34;); } The obfuscator transforms and decodes the strings into something like:\n// __data section static char var_TOKEN[] = \u0026#34;\\x00\\x1D\\xDD\\xEE\\xAB\u0026#34;; static char var_TOKEN_2[] = \u0026#34;\\x00\\x1D\\xDD\\xEE\\xAF\u0026#34;; __attribute__((constructor)) void decode_strings() { decode(var_TOKEN); decode(var_TOKEN_2); } void protect_me() { sensitive(var_TOKEN); } void protect_me_2() { sensitive(var_TOKEN_2); } Since all the strings are decoded at once in one of the first constructors, if we manage to dump the binary right after this constructor, we can recover the original strings for free.\nProgrammatically, it can be done using (again) frida-gum SDK with the following pseudocode:\n// Hook associated with ImageLoader::containsAddress void native_listener_on_enter(GumInvocationListener* listener, GumInvocationContext* ic) { static size_t CTOR_ID = 0; const uintptr_t ctor_function_addr = ic-\u0026gt;cpu_context-\u0026gt;x[1]; std::string libname = module_from_addr(ctor_function_addr); if (libname == \u0026#34;NianticLabsPlugin\u0026#34; \u0026amp;\u0026amp; CTOR_ID++ == 3) { const uintptr_t base_address = base_addr_from_ptr(ctor_function_addr); auto bin = LIEF::MachO::Parser::parse_from_memory(base_address); bin-\u0026gt;write(\u0026#34;/tmp/pokemongo_after_ctor.bin\u0026#34;); // /tmp on the iPhone  } } At end, the dumped file contains the decoded strings:\nIf we skim the __data section, we can also observe the following changes:\nA practiced eye might notice6 that some strings of the section are actually embedded in protobuf structures. We can confirm this observation by trying to infer the data as protobuf types:\nfrom . import proto_dump import lief pgo = lief.parse(\u0026#34;pokemongo_after_ctor.bin\u0026#34;) start = 0x12A51A7 end = 0x12A51E2 raw_proto = pgo.get_content_from_virtual_address(start, end - start) print(proto_dump(raw_proto)) { #3 = 4 #4 (repeated) = 1 { #1 = \u0026#34;CheatReputation\u0026#34; #2 (repeated) = { #1 = \u0026#34;UNSET\u0026#34; #2 = 0 } { #1 = \u0026#34;BOT\u0026#34; #2 = 1 } { #1 = \u0026#34;SPOOFER\u0026#34; #2 = 2 } } #5 = 8 #8 = [] } Final Words The application embeds other checks in the constructors and in the functions returned by GetN2Api. It can make a good exercise for those that are interested in.\nGenerally speaking, the application and the protections are well designed since they slow down reverse engineers. Nevertheless, anti-{jb, frida, debug} are quite difficult to protect as they need to interact with the OS through functions or syscalls with unprotected parameters. As a result, and once identified, we can bypass them.\nOne technique consists in injecting a library with Frida\u0026rsquo;s injector that aims at hooking the containsAddress() to disable/patch the functions involved in the detections:\n Nevertheless, this technique is not persistent and version-dependant.\nAfter writing this post, it turned out that its structure is very close to Reverse Engineering Starling Bank. In particular, we can find the same anti-debug and the same Frida detection routine. These similarities suggest that these two application uses the same obfuscator that also provides anti-{jb, frida, debug} as built-in.\nYou might also be interested in the recent talk of Eloi Benoist-Vanderbeken @Pass the Salt   who detailed another approach to identify and bypass jailbreak detections.\n LIEF is a tool developed at Quarkslab along with QBDI \u0026amp; Triton.    Annexes    Files that trigger the JB detection Files that should be present     /.bootstrapped_electra /cores   /Applications/Anemone.app /dev/null   /Applications/Cydia.app /etc/hosts   /Applications/SafeMode.app /etc/passwd   /Library/Frameworks/CydiaSubstrate.framework /sbin   /Library/MobileSubstrate/DynamicLibraries/FlyJB.dylb /sbin/launchd   /Library/MobileSubstrate/MobileSubstrate.dylib /sbin/mount   /Library/PreferenceBundles/LaunchInSafeMode.bundle /usr   /Library/PreferenceLoader/Preferences/LaunchInSafeMode.plist    /Library/Themes    /Library/dpkg/info/com.inoahdev.launchinsafemode.list    /Library/dpkg/info/com.inoahdev.launchinsafemode.md5sums    /bin/bash    /bin/bunzip2    /bin/bzip2    /bin/cat    /bin/chgrp    /bin/chmod    /bin/chown    /bin/cp    /bin/grep    /bin/gzip    /bin/kill    /bin/ln    /bin/ls    /bin/mkdir    /bin/mv    /bin/sed    /bin/sh    /bin/su    /bin/tar    /binpack    /bootstrap    /chimera    /electra    /etc/apt    /etc/profile    /jb    /private/var/binpack    /private/var/checkra1n.dmg    /private/var/lib/apt    /usr/bin/diff    /usr/bin/hostinfo    /usr/bin/killall    /usr/bin/passwd    /usr/bin/recache    /usr/bin/tar    /usr/bin/which    /usr/bin/xargs    /usr/lib/SBInject    /usr/lib/SBInject.dylib    /usr/lib/TweakInject    /usr/lib/TweakInject.dylib    /usr/lib/TweakInjectMapsCheck.dylib    /usr/lib/libjailbreak.dylib    /usr/lib/libsubstitute.0.dylib    /usr/lib/libsubstitute.dylib    /usr/lib/libsubstrate.dylib    /usr/libexec/sftp-server    /usr/sbin/sshd    /usr/share/terminfo    /var/mobile/Library/.sbinjectSafeMode    /var/mobile/Library/Preferences/jp.akusio.kernbypass.plist       iPhone 6 running on iOS 14.2 with checkra1n.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n We can identify them by trial and error.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n ETA: likely by the end of the year\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The Mach-O format is very suitable for this feature as the header in mapped in memory. Therefore, it eases the parsing.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n More generally, it can encode local data (strings, bytes arrays, \u0026hellip;)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Protobuf strings can be identified as they usually start with 0xA, 0xB, followed by their lengths and the string itself (see: protocol-buffers/docs/encoding)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1626566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626566400,"objectID":"5a603667ac0a847f9c12e6a764ffbd36","permalink":"/post/21-07-pokemongo-anti-frida-jailbreak-bypass/","publishdate":"2021-07-18T00:00:00Z","relpermalink":"/post/21-07-pokemongo-anti-frida-jailbreak-bypass/","section":"post","summary":"This blog post analyzes the Frida and Jailbreak detection in PokemonGO for iOS.","tags":["iOS","reverse engineering","obfuscation"],"title":"Gotta Catch 'Em All: Frida \u0026 jailbreak detection","type":"post"},{"authors":["Adrien Guinet","Romain Thomas"],"categories":null,"content":"QBDL (QuarkslaB Dynamic Loader) is a cross-platform library that enables to load ELF, PE and Mach-O binaries with an abstraction on the targeted system. It abstracts the memory model on which the binary is loaded and provides an enhanced API to the user to process symbols resolution. In a nutshell, it enables to load binaries on foreign systems without reinventing the wheel.\nHere is an example to load a Mach-O in Triton with QBDL:\nclass TritonVM(pyqbdl.TargetMemory): def __init__(self, ctx: TritonContext): super().__init__() self.ctx = ctx def mmap(self, ptr, size): return ptr def mprotect(self, ptr, size, access): return True def write(self, ptr, data): self.ctx.setConcreteMemoryAreaValue(ptr, bytes(data)) def read(self, ptr, size): return self.ctx.getConcreteMemoryAreaValue(ptr, size) class TritonSystem(pyqbdl.TargetSystem): def __init__(self, arch, ctx): super().__init__(TritonVM(ctx)) self.arch = arch self.ctx = ctx def symlink(self, loader, sym): for name, impl, addr in externalFunctions: if sym.name == name: return addr return 0 def supports(self, bin_): return pyqbdl.Arch.from_bin(bin_) == self.arch def base_address_hint(self, bin_ba, vsize): return bin_ba x86_64_arch = pyqbdl.Arch(lief.ARCHITECTURES.X86, lief.ENDIANNESS.LITTLE, True) loader = pyqbdl.loaders.MachO.from_file(args.filename, x86_64_arch, TritonSystem(x86_64_arch, ctx), pyqbdl.Loader.BIND.NOW) ","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622678400,"objectID":"56cca5f733ce0497aa03618871afae50","permalink":"/project/qbdl/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/project/qbdl/","section":"project","summary":"QuarkslaB Dynamic Loader: Generic loader for ELF, PE and Mach-O","tags":["lief","loader"],"title":"QBDL","type":"project"},{"authors":["Adrien Guinet","Romain Thomas"],"categories":null,"content":" Slides   Talk (In French)  ","date":1622678400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622678400,"objectID":"1434f07c2f56abf03dc60cddf3203049","permalink":"/publication/21-sstic-qbdl/","publishdate":"2021-06-03T00:00:00Z","relpermalink":"/publication/21-sstic-qbdl/","section":"publication","summary":"The QuarkslaB Dynamic Loader (QBDL) library aims at providing a modular and portable way to dynamically load and link binaries","tags":null,"title":"QBDL: QuarkslaB Dynamic Loader","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":" Slides   Whitepaper    Demo #1: Snapchat    Demo #2: Legu Packer  Note: The videos are intentionally quick. Do not hesite to pause them.\n","date":1601510400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601510400,"objectID":"be538b60cdac768ef1a4eb66140bfc9a","permalink":"/publication/20-bh-asia-dbi/","publishdate":"2020-10-01T00:00:00Z","relpermalink":"/publication/20-bh-asia-dbi/","section":"publication","summary":"Android applications are becoming more and more obfuscated to prevent reverse engineering. While obfuscation can be applied on both, the Dalvik bytecode and the native code, the former is more challenging to analyze due to the structure of the bytecode as well as the API provided by Android Runtime. The purpose of this talk is to present dynamic binary instrumentation techniques that can help reverse engineers to deal with obfuscated codes. These techniques aim to be obfuscator resilient so that it does not rely on a special kind of obfuscation neither a specific obfuscator.","tags":null,"title":"Dynamic Binary Instrumentation Techniques to Address Native Code Obfuscation","type":"publication"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; font-size: 87.5%; } .blue { color: blue; font-family: 'Fira Code', monospace; font-size: 87.5%; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; font-size: 87.5%; } .red { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; font-size: 87.5%; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; font-size: 87.5%; } #  Introduction In the first part of this write-up, we described the anti-frida, anti-debug and anti-root techniques used in the application and how to remove most of them.\nThis second part digs into the JNI function gXftm3iswpkVgBNDUp and the underlying whitebox implementation.\nLibrary Shimming The inputs of the function gXftm3iswpkVgBNDUp are provided by the GUI widgets and the function is triggered when we press the Generate R2Coin button. Nevertheless, the behavior of gXftm3iswpkVgBNDUp does not rely on UI features nor the application\u0026rsquo;s context1.\nTo take a closer look at the logic of gXftm3iswpkVgBNDUp, it would be pretty useful to be able to feed the function\u0026rsquo;s inputs with our own standalone binary. Basically, we would like to achieve this kind of interface:\nint main(int argc, char** argv) { void* dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); ... jbyteArray out = gXftm3iswpkVgBNDUp(env, ...); return 0; } This technique is not new and has been already described in a blog post by Caleb Fenton2. The idea is to get the JNIEnv* env variable with JNI_CreateJavaVM which is exported by the Android runtime: libart.so.\nOnce we have this variable, we can call the gXftm3iswpkVgBNDUp function as well as manipulating the JNI buffers:\n env-\u0026gt;NewByteArray() env-\u0026gt;GetArrayLength() \u0026hellip;  Long story short, we can instantiate the Android runtime with the following piece of code:\nint main(int argc, char** argv) { JavaVMOption opt[2]; opt[0].optionString = \u0026#34;-Djava.class.path=/data/local/tmp/re.pwnme.1.0.apk\u0026#34;; opt[1].optionString = \u0026#34;-Djava.library.path=/data/local/tmp\u0026#34;; JavaVMInitArgs args; args.version = JNI_VERSION_1_6; args.options = opt; args.nOptions = 2; args.ignoreUnrecognized = JNI_FALSE; void* handler = dlopen(\u0026#34;/system/lib64/libart.so\u0026#34;, RTLD_NOW); auto JNI_CreateJavaVM_f = reinterpret_cast\u0026lt;decltype(JNI_CreateJavaVM)*\u0026gt;(dlsym(handler, \u0026#34;JNI_CreateJavaVM\u0026#34;)); JNI_CreateJavaVM_f(\u0026amp;jvm, \u0026amp;env, \u0026amp;args); } Then, we can resolve the gXftm3iswpkVgBNDUp function with the base address of libnative-lib.so and its offset 0x9B41C:\nvoid* hdl = dlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); uintptr_t base_address = get_base_address(\u0026#34;libnative-lib.so\u0026#34;); using gXftm3iswpkVgBNDUp_t = jbyteArray(*)(JNIEnv*, jobject, jbyteArray, jbyte); gXftm3iswpkVgBNDUp = reinterpret_cast\u0026lt;gXftm3iswpkVgBNDUp_t\u0026gt;(base_address + 0x9B41C); Finally, we can run the function with our own inputs:\nstd::string pin_amount = \u0026#34;0000123400004567\u0026#34;; jbyteArray array = convert_to_jbyteArray(pin_amount, ptr); jbyteArray jencrypted_buffer = gXftm3iswpkVgBNDUp(env, nullptr, array, 0xF0); const std::vector\u0026lt;uint8_t\u0026gt; encrypted_buffer = from_jbytes(jencrypted_buffer); std::string hex_str = to_hex(encrypted_buffer); LOG_INFO(\u0026#34;{} --\u0026gt; {}\u0026#34;, pin_amount, ref_str);  The whole implementation is available here .   Function Tracing Now that we are able to run the gXftm3iswpkVgBNDUp function without the GUI layer, we can easily create an interface with QBDI:\nVM vm; vm.addInstrumentedModule(\u0026#34;libnative-lib.so\u0026#34;); ... jbyteArray array = to_jarray(pin_amount, ptr); jbyteArray qbdi_encrypted_buffer; vm.call( /* ret */ reinterpret_cast\u0026lt;uintptr_t*\u0026gt;(\u0026amp;qbdi_encrypted_buffer), /* target */ reinterpret_cast\u0026lt;uintptr_t\u0026gt;(gXftm3iswpkVgBNDUp), /* params */ { /* p_0: JNIEnv* */ reinterpret_cast\u0026lt;rword\u0026gt;(env), /* p_1: jobject thiz */ reinterpret_cast\u0026lt;rword\u0026gt;(nullptr), /* p_2: inbuffer */ reinterpret_cast\u0026lt;rword\u0026gt;(array), 0xF0 } ); The execution in QBDI without user\u0026rsquo;s callbacks takes about 3min 30s which is quite huge compared to the real execution that takes about 853ms:\nThis overhead is mostly due to the function 0x1038f0 that is executed ~20 000 times. After a quick analysis, it turns out that this function is not relevant to instrument to break the whitebox. We can force its real execution (i.e. outside QBDI) by removing the function\u0026rsquo;s address from the instrumented range3.\nstatic constexpr uintptr_t HEAVY_FUNCTION = 0x1038f0; vm.removeInstrumentedRange( base_address + HEAVY_FUNCTION, base_address + HEAVY_FUNCTION + 1 ); This small adjustment drops the execution to 3'30sec.\n Some cryptographic algorithms can be fingerprinted either with predefined constants or with their memory accesses. According to the Quarkslab\u0026rsquo;s blog post: Differential Fault Analysis on White-box AES Implementations, the whitebox lookup tables are likely to be stored in the .data, .rodata, ... sections.\nBy looking at the sizes of these sections, only the .data section seems to have an appropriate size. We can generate a memory trace on this section to see if we can outline some patterns. It can be made with the following piece of code:\nvm.recordMemoryAccess(MEMORY_READ_WRITE); vm.addMemRangeCB( /* .data start address */ base_address + 0x127000, /* .data end address */ base_address + 0x127000 + 0x8e000, /* Record both: reads and writes */ MEMORY_READ_WRITE, /* Memory callback */ [] (VM* vm, GPRState*, FPRState*, void* data) { auto ctx = reinterpret_cast\u0026lt;qbdi_ctx*\u0026gt;(data); /* * \u0026#39;for\u0026#39; loop since on AArch64 we can have multiple reads / writes * at once. (e.g. stp x0, x1, [sp, #128]) */ for (const MemoryAccess\u0026amp; mem_access : vm-\u0026gt;getInstMemoryAccess()) { ctx-\u0026gt;trace-\u0026gt;push_back({ mem_access.instAddress - base_address, mem_access.accessAddress - base_address, mem_access.size, }); } return VMAction::CONTINUE; }, \u0026amp;ctx);  Generating the memory trace takes about 11sec which is acceptable.   It leads to the following graph in which we can notice a characteristic pattern at the end of the trace:\nFault Injection The pattern at the end of the trace is quite characteristic of AES-128 where we can identify 10 rounds. We now have all the necessary information to make a fault injection attack:\n We can identify the 9th round We can accurately fault the .data section thanks to the memory trace   The memory trace is available in the  mem_trace.json file of the repository.   To efficiently make the injection, we can first reduce the memory addresses to only keep those that are used in the last 2 rounds:\ntrace_file = CWD / \u0026#34;..\u0026#34; / \u0026#34;assets\u0026#34; / \u0026#34;mem_trace.json\u0026#34; trace = json.loads(trace_file.read_bytes())[0] # Keep the entries that are involved in the last 2-rounds (empirical number) nice_trace = trace[-1000:] Then, we can use our shim mechanism to inject the faults in the .data section with the addresses previously selected. Moreover, we can reduce the set of .data addresses with the faults that introduce exactly 4 differences in the ciphertext:\n// Make sure the .data section is writable mprotect( reinterpret_cast\u0026lt;void*\u0026gt;(base_address + /* .data */ 0x127000), 0x8e000, PROT_READ | PROT_WRITE ); for (uintptr_t fault_addr : selected_addresses) { uint8_t\u0026amp; target_byte = *reinterpret_cast\u0026lt;uint8_t*\u0026gt;(base_address + fault_addr); uint8_t backup = target_byte; // Fault 1 byte:  target_byte ^= 0x33; // Run the whitebox with the faulty byte  const std::vector\u0026lt;uint8_t\u0026gt; encrypted = encrypt(msg); // Restore the original byte  target_byte = backup; // Compute the number of errors  // ... } Finally, with the subset of the addresses that affect exactly 4 bytes, we can generate several faults for a given address:\nfor (uintptr_t nice_fault_addr : four_bytes_fault_addresses) { for (size_t i = 0; i \u0026lt; 255; ++i) { const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; output = inject_fault(addr, PIN_AMOUNT, i); const size_t nb_errors = get_error(genuine_value, output); if (nb_errors == 4 and unique.insert(output).second) { // Record the entry ...  } } } The aforementioned code gives an idea about how to generate the faults. One can find the whole implementation in this file: shim-whitebox/src/main.cpp that produces this set of files assets/wb-traces.\nKey Extraction Thanks to the  Side-Channel Marvels project, we can use JeanGrey \u0026mdash; developed by Philippe Teuwen \u0026mdash; to recover the whitebox\u0026rsquo;s key from the faulty traces:\nimport pathlib import phoenixAES CWD = pathlib.Path(__file__).parent trace_dir = CWD / \u0026#34;..\u0026#34; / \u0026#34;assets\u0026#34; / \u0026#34;wb-traces\u0026#34; for f in trace_dir.iterdir(): x = phoenixAES.crack_file(f) if x is not None: print(x, f.name) It provides the following results which enable to retrieve the key:\n$ python wb_key_recovery.py ..8D....7F............9A....79.. injection-1a930d.trace ..8D....7F............9A....79.. injection-1a95bd.trace ....19....62....B0............8F injection-1a91b2.trace ....19....62....B0............8F injection-1a8fdf.trace 76............1E....D3....E1.... injection-1a8549.trace ......E1....A0....CD....28...... injection-1a8978.trace ....19....62....B0............8F injection-1a90ce.trace ....19....62....B0............8F injection-1a8efd.trace r 2 p 4 y 1 s N 0 w S e c u r 3 Finally, we can verify that r2p4y1sN0wSecur3 is the right key by trying to decrypt 9497cdf1df2600e7f63778d0ae91dcbb4:\nfrom Crypto.Cipher import AES WB_KEY = b\u0026#34;r2p4y1sN0wSecur3\u0026#34; cipher = AES.new(WB_KEY, AES.MODE_ECB) output = cipher.decrypt(bytes.fromhex(\u0026#34;9497cdf1df2600e7f63778d0ae91dcbb\u0026#34;)) print(output.decode()) $ python ./aes_test.py 0000123400004567 Side note about the .data section Most of the obfuscators encode strings so that we don\u0026rsquo;t have any clue about functions' logic. The obfuscator used in the challenge follows this rule and running the strings utility on the library does not reveal any interesting information.\nNevertheless, we can find a lot of .datadiv_decode\u0026lt;random hex\u0026gt; in the ELF constructors of the library. As explained in the previous part, they are generated by the obfuscator and aimed to decode the strings.\nSince these functions are in the ELF constructors, this means that they are executed as soon as the library is loaded. In particular, when calling dlopen(...) these constructors are executed. It can be confirmed by dumping the .data section right after dlopen():\ndlopen(\u0026#34;libnative-lib.so\u0026#34;, RTLD_NOW); std::ofstream ofs{fmt::format(\u0026#34;/data/local/tmp/{}\u0026#34;, output)}; auto start = reinterpret_cast\u0026lt;const char*\u0026gt;(base_address + 0x127000); ofs.write(start, /* sizeof(.data) */ 0x8d49f); Then, we can compare the bytes distribution with binvis.io:\nAt the end of the in-memory .data section, we can found interesting strings used to detect Frida and the device\u0026rsquo;s root state.\nConclusion Thanks again to Eduardo Novella ( @enovella_) and Gautam Arvind ( @darvincisec) for this second part of the challenge :)\nAlso thanks to  Quarkslab that allowed this publication. One can find related blog posts about whitebox attacks on the Quarkslab\u0026rsquo;s blog:\n   Introduction to Whiteboxes and Collision-Based Attacks With QBDI  by Paul Hernault ( @0xAcid)\n   When SideChannelMarvels meet LIEF \n   Differential Fault Analysis on White-box AES Implementations by Philippe Teuwen ( @doegox). I used this blog post as a reference to resolve this part of the challenge.\n  References   https://developer.android.com/reference/android/content/Context\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n QBDI will execute the function using the ExecBroker mechanism.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n It is the output of the function when entering 1234 in the PIN field and 4567 in the amount field.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1601164800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601164800,"objectID":"22a0d53d8bd74d4cfb25cc6fcaf6938b","permalink":"/post/20-09-r2con-obfuscated-whitebox-part2/","publishdate":"2020-09-27T00:00:00Z","relpermalink":"/post/20-09-r2con-obfuscated-whitebox-part2/","section":"post","summary":"This second blog post explains how to recover the whitebox's key from the obfuscated library libnative-lib.so","tags":["android","reverse engineering","write-up","obfuscation","whitebox","cryptography"],"title":"r2-pay: whitebox (part 2)","type":"post"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .green { color:green; font-family: 'Fira Code', monospace; font-size: 87.5%; } .blue { color: blue; font-family: 'Fira Code', monospace; font-size: 87.5%; } .orange { color: #FF6347; font-family: 'Fira Code', monospace; font-size: 87.5%; } .red { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-comment { color: #df2b04; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-keyword { color: #A90D91; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-literal { color: #1C01CE; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-preproc { color: #633820; font-family: 'Fira Code', monospace; font-size: 87.5%; } .hl-strings { color: #C41A16; font-family: 'Fira Code', monospace; font-size: 87.5%; } .yellow { color: #CC7000; font-family: 'Fira Code', monospace; font-size: 87.5%; } #  Introduction This series of blog posts explains one way to resolve the r2-pay challenge released during the r2con2020 conference. This first part is about the anti-analysis tricks used to hinder reverse-engineering while the second part will be more focused on breaking the whitebox.\nThe resolution took me more than a week-end but it covers nice topics that worth it: obfuscation \u0026amp; whitebox. It was also the opportunity to practice attacks against whiteboxes and to test SideChannelMarvels/JeanGrey developed by Philippe Teuwen (aka. @doegox).\nThe challenge has been resolved with the AArch64 version on a device running on Android 9 and rooted with Magisk.\n Here are the files used in this write-up:\n re.pwnme.1.0.apk - af019d3016720592aade7bde9890110c\n libnative-lib.so (arm64-v8a version)\n  Overview When opening the application on a non-tempered device (or with Magisk hide enabled), we are asked to enter a PIN and an amount that is used to generate a token.\nTo resolve the challenge, we have to find the master key that is used to generate the token. Few days before the CTF I was told that one of the challenges would involve an obfuscated whitebox\u0026hellip;\nThe main interface of the APK is located in the Java class re.pwnme.MainActivity which forwards the user inputs (PIN \u0026amp; amount) to a JNI function named gXftm3iswpkVgBNDUp. This function takes the concatenated input $PIN\\ ||\\ Amount$ and returns the token as a byte array.\nThe static constructor of the class loads the \u0026ldquo;native-lib\u0026rdquo; library which is available for the architectures: arm64-v8a, armeabi-v7a, and x86_64. Unsurprisingly, this library is obfuscated and some symbols suggest that it has been compiled with a fork of O-LLVM 1.\nIn addition, the library does not export the expected symbol Java_re_pwnme_MainActivity_gXftm3iswpkVgBNDUp but prefers to use the JNI_OnLoad technique 2. JNI_OnLoad() is also obfuscated along with control-flow-flattening.\nThe main task of the challenge is to understand the logic of the gXftm3iswpkVgBNDUp function to figure out how the token is generated.\nAnti-Root \u0026amp; Anti-Frida Along with the libnative-lib.so library, the applications embeds another library libtool-checker.so whose name sounds quite familiar: it comes from the open-source project rootbeer which is used to detect if the device is rooted.\nSome of the root-checks are done in the MainActivity class and if the device is rooted the application raises an exception by dividing a number with 0.\nOn this point, we can disable the check by using Frida on the rootbeer\u0026rsquo;s functions involved in the detection:\n// frida -U -l ./bypass-root.js --no-pause -f re.pwnme Java.perform(function () { var RootCheck = Java.use('\\u266b.\\u1d64'); RootCheck['₤'].implementation = function () { console.log(\u0026quot;Skip root\u0026quot;); return false; } RootCheck['θ'].overload().implementation = function () { console.log(\u0026quot;Skip root\u0026quot;); return false; } }) Nevertheless, the application still crashes as soon as it starts and generates the following backtrace:\nF libc : Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 in tid 8875 (re.pwnme), pid 8849 (re.pwnme) F DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** F DEBUG : Build fingerprint: \u0026#39;google/taimen/taimen:9/PQ3A.190801.002/5670241:user/release-keys\u0026#39; F DEBUG : Revision: \u0026#39;rev_10\u0026#39; F DEBUG : ABI: \u0026#39;arm64\u0026#39; F DEBUG : pid: 8849, tid: 8875, name: re.pwnme \u0026gt;\u0026gt;\u0026gt; com.google.android.gms \u0026lt;\u0026lt;\u0026lt; F DEBUG : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 F DEBUG : x0 0000007f041f6610 x1 0000007f2565c800 x2 0000007f25600000 x3 000000000000001d F DEBUG : x4 000000000000005c x5 0000000000000001 x6 0000000000000001 x7 0000000000000000 F DEBUG : x8 0000007f041f6610 x9 0000007f041f6600 x10 00000000fa929095 x11 00000000000035b2 F DEBUG : x12 00000000e34d79ac x13 00000000fffffff7 x14 00000000a139577d x15 0000000000000001 F DEBUG : x16 0000007fa66af220 x17 0000007fa65e3608 x18 0000000000000000 x19 0000007f041f6680 F DEBUG : x20 0000000000000000 x21 0000000000000000 x22 0000229100002291 x23 0000000000000000 F DEBUG : x24 0000007f041ff570 x25 0000007f04102000 x26 0000007fab1ad5e0 x27 0000007f0421a690 F DEBUG : x28 0000007f04209080 x29 0000007f041ff490 F DEBUG : sp 0000007f041f65f0 lr 0000007f0423de04 pc 0000007f0423f980 F DEBUG : F DEBUG : backtrace: F DEBUG : #00 pc 000000000003f980 /data/app/re.pwnme-7O3ynhSmMsg2_E5_uqbQxQ==/lib/arm64/libnative-lib.so The backtrace suggests that other checks are performed in the native library. By looking at the ELF\u0026rsquo;s constructors, we can notice two functions that differ from those generated by the obfuscator:\n .datadiv_decode13003153710004289592 functions are in the ELF constructors since they decode global strings that need to be available as soon as the library is loaded.   By tracing these functions with QBDI, we quickly understand that sub_9080 iterates over /proc/self/maps with the syscalls openat/read that are located at the addresses 0x009870 and 0x00b448.\nThen, we observe the following sequence:\n0x011fb0: syscall: openat(0xffffffffffffff9c, \u0026#39;/system/lib64/libc.so\u0026#39;) 0x012884: syscall: read(51, 0x7ffc006c58, 64): \u0026#39;ELF@)@8@\u0026#39; 0x013170: syscall: lseek(51, 0x112918, 0) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;/ \u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;B88\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;J\u0026gt;\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;RoP)\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;\\o((\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;io\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;xo0\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64) 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;Bxx`-\u0026#39; 0x0145f8: syscall: read(51, 0x7ffc006c18, 64): \u0026#39;PP`\u0026#39; 0x0151f4: malloc(0x18): 0x7f0c21f4c0 0x0156e4: syscall: lseek(51, 0x1a650, 0) 0x015a68: malloc(0x1e60): 0x7f0acb2000 0x015fa0: syscall: read(51, 0x7f0acb2000, 0x1e60): \u0026#39;{n@b r@ v@ z@ ~@ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ A A\u0026#34; AB Ab A A A A \u0026#34;A \u0026amp;A\u0026#34; *AB .Ab 2A 6A :A \u0026gt;A BA FA\u0026#34; JAB NAb RA VA ZA ^A bA fA\u0026#34; jAB nAb rA vA zA ~A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A B B\u0026#34; BB Bb B B B B \u0026#34;B \u0026amp;B\u0026#34; *BB .Bb 2B 6B :B \u0026gt;B BB FB\u0026#34; JBB NBb RB VB ZB ^B bB fB\u0026#34; jBB nBb rB vB zB ~B B B\u0026#34; BB Bb B B B B B B\u0026#34; B ...\u0026#39; 0x016cfc: free(0x7f0acb2000) -\u0026gt; {n@b r@ v@ z@ ~@ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ @ @\u0026#34; @B @b @ @ @ @ A A\u0026#34; AB Ab A A A A \u0026#34;A \u0026amp;A\u0026#34; *AB .Ab 2A 6A :A \u0026gt;A BA FA\u0026#34; JAB NAb RA VA ZA ^A bA fA\u0026#34; jAB nAb rA vA zA ~A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A A A\u0026#34; AB Ab A A A A B B\u0026#34; BB Bb B B B B \u0026#34;B \u0026amp;B\u0026#34; *BB .Bb 2B 6B :B \u0026gt;B BB FB\u0026#34; JBB NBb RB VB ZB ^B bB fB\u0026#34; jBB nBb rB vB zB ~B B B\u0026#34; BB Bb B B B B B B\u0026#34; B ... 0x017118: syscall: close(51) From this output, we can infer the following logic:\n 0x011fb0: the function opens the libc 0x012884: it reads the ELF header 0x013170: it jumps to the ELF sections table 0x0145f8: it looks for the .plt section 0x015a68, 0x015fa0: it reads the content of the .plt section  These operations suggest that the function checks if the .plt of /system/lib64/libc.so is not tampered with. In particular, if we use Frida on a libc\u0026rsquo;s function this check won\u0026rsquo;t pass.\nAfter this check, the function sub_9080 spawns a thread:\n0x0195dc: pthread_create(0xf1079f10, 0x0, 0x1a690, 0x0) The libc integrity check makes more sense as it is probably used to protect the library against a hook of pthread_create().\nThe thread\u0026rsquo;s routine sub_1a690 starts by making two calls to the mathematical function tan():\n0x01b774: tan(0.): 0. 0x01b79c: tan(-7832.0): -0.00951489 0x01cc74: memcpy(0x7ffc006598, libnative-lib.so!0x1267f0, 80) -\u0026gt; !7Nl 0x01ceb8: rand() 0x01f774: tan(0.): 0. 0x01f79c: tan(-7832.0): -0.00951489 My understanding of these calls is that the application tries to protect against tools that would not support floating-point instructions such as FCMP or FMOV. In addition, I think that if we mock the behavior of tan() with a constant value it would trigger a crash.\nThen it follows a check of TracerPid value in /proc/self/status. This value is set when the process is ptrace-debugged (which is the case with gdb). Dynamically, we observe syscalls that open /proc/self/status and read the content byte-per-byte:\n0x020ee0: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/status\u0026#39;): 51 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;N\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;a\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;m\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;:\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1) 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;r\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;.\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;p\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;w\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;n\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;m\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1) 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;S\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;t\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;a\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;t\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;e\u0026#39; 0x0231e8: syscall: read(51, 0x7ffc00656c, 1): \u0026#39;:\u0026#39; ... Anti-Frida #1 Still in the thread\u0026rsquo;s routine sub_1a690, the function checks if Frida is running by looking at all the values of /proc/self/task/\u0026lt;tid\u0026gt;/status and by checking if one of the names is gmain. It turns out that it\u0026rsquo;s the case when Frida is used in the application :-)\n0x0368e4: snprintf(\u0026#39;/proc/self/task/9719/status\u0026#39;, \u0026#39;/proc/self/task/%s/status\u0026#39;): \u0026#39;/proc/self/task/9719/status\u0026#39; 0x036a1c: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/task/9719/status\u0026#39;) 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;N\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;a\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;m\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;e\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;:\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1) 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;g\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;m\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;a\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;i\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1): \u0026#39;n\u0026#39; 0x03897c: syscall: read(73, 0x7ffc400af4, 1) 0x03897c: closedir() # Crash! To bypass this check, one can statically patch the syscall or we can dynamically change the behavior of snprintf(..., '/proc/self/task/%s/status') in order to always returns the same status (e.g. /proc/self/task/123/status). Concretely, it could be done by hooking snprintf and by forcing the output string to /proc/self/task/123/status.\nAnti-Frida #2 Still in the sub_1a690 function, the anti-frida checks continue by inspecting the file descriptors of the process. It iterates over /proc/self/fd/%s and looks at the underlying symlink.\nFrida server \u0026mdash; which is running globally on the device \u0026mdash; and Frida agent \u0026mdash; which is injected in the process \u0026mdash; communicate with named pipes that are associated with a file descriptor.\nIf Frida server is running, we can observe the following values:\n0x04308c: lstat(\u0026#39;/proc/self/fd/32\u0026#39;) 0x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/32\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;anon_inode:[eventfd]\u0026#39; 0x041844: readdir(\u0026#39;33\u0026#39;) 0x043078: snprintf(\u0026#39;/proc/self/fd/33\u0026#39;, \u0026#39;/proc/self/fd/%s\u0026#39;): \u0026#39;/proc/self/fd/33\u0026#39; 0x04308c: lstat(\u0026#39;/proc/self/fd/33\u0026#39;) 0x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/33\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;anon_inode:[eventfd]\u0026#39; 0x041844: readdir(\u0026#39;34\u0026#39;) 0x043078: snprintf(\u0026#39;/proc/self/fd/34\u0026#39;, \u0026#39;/proc/self/fd/%s\u0026#39;): \u0026#39;/proc/self/fd/34\u0026#39; 0x04308c: lstat(\u0026#39;/proc/self/fd/34\u0026#39;) 0x043448: syscall: readlinkat(0xffffffffffffff9c, \u0026#39;/proc/self/fd/34\u0026#39;, 0x7ffbffdc10, 256): \u0026#39;/data/local/tmp/re.frida.server/linjector-500\u0026#39; # Crash! In this case, the file descriptor 34 is associated with /data/local/tmp/re.frida.server/linjector-500 which triggers the detection and the application crashes.\nAs for /proc/self/task/\u0026lt;tid\u0026gt;/status, one can disable this check by statically patching the syscalls or by dynamically changing the result of readlinkat(). For instance, we can use QBDI to instrument syscall instructions and process the result of readlinkat() in an user callback:\nvm.addMnemonicCB(\u0026#34;SVC\u0026#34;, POST_INST, [] (VMInstanceRef vm, GPRState* gprState, FPRState*, void* data) { if (gprState-\u0026gt;x8 != __NR_readlinkat) { return VMAction::CONTINUE; } std::string buf = reinterpret_cast\u0026lt;char*\u0026gt;(gprState-\u0026gt;x2); if (buf.find(\u0026#34;re.frida.server\u0026#34;) != std::string::npos) { static const std::string FAKE_VALUE = \u0026#34;anon_inode:[eventfd]\u0026#34;; // Bypass Frida detection!  memcpy( reinterpret_cast\u0026lt;void*\u0026gt;(gprState-\u0026gt;x2), reinterpret_cast\u0026lt;void*\u0026gt;(FAKE_VALUE.c_str()), FAKE_VALUE.size() + 1 ); gprState-\u0026gt;x0 = FAKE_VALUE.size() + 1; } return VMAction::CONTINUE; }, ctx); Anti-Frida #3 ? I\u0026rsquo;m not sure if the following calls sequence is used to check the libc\u0026rsquo;s integrity against Frida but at the end of the thread\u0026rsquo;s routine, we can observe these syscalls:\n0x048ff0: syscall: openat(0xffffffffffffff9c, \u0026#39;/proc/self/maps\u0026#39;): 51 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;1\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;2\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;c\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; 0x04ae6c: syscall: read(51, 0x7ffc006578, 1): \u0026#39;0\u0026#39; ... 0x0513f8: sscanf(\u0026#39;7fa65c0000-7fa65dc000 r-xp 00000000 08:07 1275/system/lib64/libc.so\u0026#39;, \u0026#39;%lx-%lx %s %s %s %s %s\u0026#39;) 0x056034: syscall: close(51) The result of sscanf() could be used to check the page permissions (e.g. rwxp) or to the libc\u0026rsquo;s base address (to check if it is consistent).\nAnti-Root In addition to the root-beer detection, the library embeds another root detection located in the second ELF constructor. This constructor \u0026mdash; sub_77D14 \u0026mdash; performs the same early checks as the first constructor on the libc\u0026rsquo;s .plt integrity before spawning another thread routine, sub_98c00.\n0x08861c: pthread_create(0xfa780b70, 0x0, 0x98c00, 0x0) By tracing the thread\u0026rsquo;s routine, we notice that it checks if su files are present on the device through three different calls:\n One call to open(): 0x099180: open('/system/xbin/su') One syscall to openat(): 0x0992a4: syscall: openat(\u0026hellip;, '/data/su') One syscall to faccessat(): 0x0993f0: syscall: faccessat('/sbin/su')  0x099180: open(\u0026#39;/data/local/su\u0026#39;): -1 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/su\u0026#39;): -2 0x0993f0: syscall: faccessat(\u0026#39;/data/local/su\u0026#39;): -2 0x099180: open(\u0026#39;/data/local/bin/su\u0026#39;): -1 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/bin/su\u0026#39;): -2 0x0993f0: syscall: faccessat(\u0026#39;/data/local/bin/su\u0026#39;): -2 0x099180: open(\u0026#39;/data/local/xbin/su\u0026#39;): -1 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/data/local/xbin/su\u0026#39;): -2 0x0993f0: syscall: faccessat(\u0026#39;/data/local/xbin/su\u0026#39;): -2 0x099180: open(\u0026#39;/sbin/su\u0026#39;): 51 0x0992a4: syscall: openat(0xffffffffffffff9c, \u0026#39;/sbin/su\u0026#39;): 52 0x0993f0: syscall: faccessat(\u0026#39;/sbin/su\u0026#39;): 52 Crash! By forcing the results of these functions to -1 or -2, we can disable the checks.\nHere is the list of the su-files that are used in this detection:\n /data/local/su /data/local/bin/su /data/local/xbin/su /sbin/su /su/bin/su /system/bin/su /system/bin/.ext/su /system/bin/failsafe/su /system/sd/xbin/su /system/usr/we-need-root/su /system/xbin/su /cache/su /data/su /dev/su  At the end of the thread\u0026rsquo;s routine, we can also observe the following calls that are probably used to check if the application is running on a real Android system.\n0x099e30: syscall: faccessat(\u0026#39;/system\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/system/bin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/system/sbin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/system/xbin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/vendor/bin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/sbin\u0026#39;) 0x099e30: syscall: faccessat(\u0026#39;/etc\u0026#39;) Static bypass with LIEF In the previous sections, we described the anti-root, anti-debug and anti-frida checks made in the ELF constructors. The same dynamic checks are also performed in the gXftm3iswpkVgBNDUp function at the following locations:\n 0x09f2f8: /proc/self/status 0x0d4840: /proc/self/fd/ 0x0dec8c: /proc/self/task/\u0026lt;tid\u0026gt;/status  While the checks in gXftm3iswpkVgBNDUp can be dynamically disabled when instrumenting the function, the checks in the ELF constructors are annoying.\nOne way to disable the checks in the thread\u0026rsquo;s routines is to disable the pthread_create(...). It can be achieved by patching the .plt entry associated with the function:\nmov x0, xzr; ret; Thanks to llvm-mc, we can get the raw bytes of these instructions:\n$ echo \u0026quot;mov x0, xzr;ret;\u0026quot;|llvm-mc -arch=aarch64 -show-encoding .text mov x0, xzr // encoding: [0xe0,0x03,0x1f,0xaa] ret // encoding: [0xc0,0x03,0x5f,0xd6] Finally, we can patch the .plt with LIEF:\nimport lief lib = lief.parse(\u0026#34;./libnative-lib.so\u0026#34;) lib.patch_address(0x5870, [0xe0,0x03,0x1f,0xaa]) lib.patch_address(0x5874, [0xc0,0x03,0x5f,0xd6]) lib.write(\u0026#34;./libnative-lib-patched.so\u0026#34;) Using these patches and the Frida script exposed in the first section, we are able to load the application but the other detections are triggered in gXftm3iswpkVgBNDUp. Nevertheless, with the Frida\u0026rsquo;s stalker or QBDI we can trace the instructions and disable the other checks.\nIf one wants to completely bypass all the protections statically, here are the patches:\nimport lief lib = lief.parse(\u0026#34;./libnative-lib.so\u0026#34;) # Keys are str objects for a better understanding :) INST = { \u0026#34;mov x0, #0\u0026#34;: [0xe0, 0x03, 0x1f, 0xaa], \u0026#34;ret\u0026#34;: [0xc0, 0x03, 0x5f, 0xd6], \u0026#34;nop\u0026#34;: [0x1f, 0x20, 0x03, 0xd5], } PATCHES = [ # Patch the .plt entry of pthread_create (0x5870, INST[\u0026#34;mov x0, #0\u0026#34;]), (0x5874, INST[\u0026#34;ret\u0026#34;]), # Disable anti-frida checks (0x0d718c, INST[\u0026#34;mov x0, #0\u0026#34;]), # /proc/self/fd : patch the result of readlinkat syscall (0x0e1940, INST[\u0026#34;mov x0, #0\u0026#34;]), # /proc/self/task/\u0026lt;tid\u0026gt;/status: patch the result of read syscall # Disable .text integrity checks (0xB64D0, INST[\u0026#34;nop\u0026#34;]), ] for patch in PATCHES: lib.patch_address(*patch) lib.write(\u0026#34;libnative-lib.so\u0026#34;) When writing this write-up, I realized that patching the syscalls involved in the anti-frida (/proc/self/fd/ and /proc/self/task/\u0026lt;tid\u0026gt;/status) makes the application crash.\nIt turns out that the library seems to implement code integrity on the .text section that I didn\u0026rsquo;t notice when running the function through QBDI. Nevertheless, by tracing the basic block3 we can identify the basic block involved in the integrity check and patch it.\n The scripts and the patched library are available here .   Regarding JNI_OnLoad(), a trace generated with QBDI\u0026rsquo;s ExecBroker leads to following result:\nJNI_OnLoad() { 0x09af3c: GetEnv(0x7fcb507460, 0x10006) 0x09b0ac: FindClass(\u0026#34;re/pwnme/MainActivity\u0026#34;): 537 0x09b1b4: RegisterNatives() gXftm3iswpkVgBNDUp ([BB)[B -\u0026gt; \u0026#34;libnative-lib.so@0x9b41c\u0026#34; } Then, we can extract the function\u0026rsquo;s offset: gXftm3iswpkVgBNDUp: 0x9b41c.\nSummary \u0026amp; Conclusion Whilst Frida detections are usually based on sockets and library names in /proc/self/maps, this challenge introduces two detections based on named pipes:/proc/self/fd and thread status: /proc/self/task/\u0026lt;tid\u0026gt;/status which are pretty cool :-)\nThese checks are performed in two locations:\n The ELF constructors The function gXftm3iswpkVgBNDUp()  The implementation in the ELF constructors might be tricky to analyse since the functions are called before any other classical functions (which includes JNI_OnLoad()). Nevertheless, thanks to the interface of the ELF loader, it exposes the function call_array(...)4 which is handy to process the ELF constructors.\n This function is mangled as __dl__ZL10call_arrayIPFviPPcS1_EEvPKcPT_mbS5_ in /system/bin/linker64   Since QBDI is not detected in this challenge, it\u0026rsquo;s a good opportunity to give it a try:\n https://github.com/QBDI/QBDI Acknowledgments Thanks to Eduardo Novella ( @enovella_) and Gautam Arvind ( @darvincisec) for this interesting and realistic challenge they created!\nAlso thanks to  Quarkslab that allowed this publication. For those who are interested in similar topics, you can take a look at the Quarkslab\u0026rsquo;s blog.\nReferences    GoSSIP-SJTU/Armariris - StringObfuscation.cpp#L140\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.android.com/training/articles/perf-jni#native-libraries\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  addVMEventCB(VMEvent::BASIC_BLOCK_ENTRY, ...);\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  linker/linker_soinfo.cpp:420\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":160056e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":160056e4,"objectID":"9caa668feaa147d7e3172fbb0748659d","permalink":"/post/20-09-r2con-obfuscated-whitebox-part1/","publishdate":"2020-09-20T00:00:00Z","relpermalink":"/post/20-09-r2con-obfuscated-whitebox-part1/","section":"post","summary":"This first blog post describes the protections in the challenge r2-pay.","tags":["android","reverse engineering","write-up","obfuscation","whitebox"],"title":"r2-pay: anti-debug, anti-root \u0026 anti-frida (part 1)","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Legu Unpacker Scripts to unpack Android applications protected by Tencent Legu. It only works with versions 4.1.0.15 and 4.1.0.18 of Legu.\nBlog post: https://blog.quarkslab.com/a-glimpse-into-tencents-legu-packer.html\nOverview The original DEX files are located in assets/0OO00l111l1l with the following layout:\nOne can find the details of this structure in the Kaitai file: legu_packed_file.ks\nThe hashmap embedded in the second part is described in the legu_hashmap.ks file:\npylegu  pylegu contains the Python bindings to decrypt and uncompress the data embedded in assets/0OO00l111l1l.\nTo compile and install pylegu:\n$ cd pylegu $ python3.7 ./setup.py build -j4 install --user $ python -c \u0026#34;import pylegu\u0026#34; One could also use jap/pyucl to decompress the data and aguinet/dragonffi to bind the custom implementation of XTEA.\nGet Started The sample com.intotherain.voicechange.apk is a suspicious application that can be unpacked as follows:\n$ python ./unpack.py ./samples/com.intotherain.voicechange.apk [+] Legu version: 4.1.0.15 [+] Password is \u0026#39;IPk2Hw7AKTuIQBlc\u0026#39; [+] Number of dex files: 1 [+] Unpacking #1 DEX files ... [+] dex 0 compressed size: 0x1619a3 [+] dex 0 uncompressed size: 0x5671f8 [+] Unpacking #1 hashmap ... [+] hashmap 0 compressed size: 0x4399c [+] hashmap 0 uncompressed size: 0x95558 [+] Unpacking #1 packed methods ... [+] packed methods 0 compressed_size: 0xf4636 [+] packed methods 0 uncompressed_size: 0x1e3072 [+] Stage 2: Patching DEX files [+] Unpacked APK: unpacked.apk The unpacked DEX files are located in the unpacked.apk file.\nRequirements  Python \u0026gt;= 3.7 Kaitai Struct LIEF pylegu  ","date":1579737600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579737600,"objectID":"a456ba06b0f13adb55cc423bbaa4319d","permalink":"/project/legu_unpacker/","publishdate":"2020-01-23T00:00:00Z","relpermalink":"/project/legu_unpacker/","section":"project","summary":"Scripts to unpack Android applications protected by Tencent Legu","tags":["android"],"title":"Tencent Legu Unpacker","type":"project"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" .packedfile { color:green; font-family: 'Lucida Console', monospace; } .keyfile { color: blue; font-family: 'Lucida Console', monospace; } .libshell { color: #FF6347; font-family: 'Lucida Console', monospace; } .tencentclass { color: #df2b04; font-family: 'Lucida Console', monospace; }   This post has been originally posted on the Quarkslab\u0026rsquo;s Blog   Introduction This blog post deals with the Legu packer, an Android protector developed by Tencent that is currently one of the state-of-the-art solutions to protect APK DEX files. The packer is updated frequently and this blog post focuses on versions 4.1.0.15 and 4.1.0.18.\nOverview An application protected with Legu is composed of two native libraries: libshell-super.2019.so and libshella-4.1.0.XY.so as well as raw binary files embedded in the resources of the APK:\n tosversion 0OO00l111l1l 0OO00oo01l1l o0oooOO0ooOo.dat  The main logic of the packer is located in the native library libshell-super.2019.so which basically unpacks and loads the protected DEX files from the resources.\nSome functions of the library are obfuscated but thanks to Frida/QBDI their analysis is not a big deal.\nInternals Basically, the original DEX files are located in the assets/0OO00l111l1l file along with the information required to unpack them.\nThe following figure lays out the structure of this file.\nIn the assets/0OO00l111l1l file, the first part contains the original DEX files with the same number of classes\u0026lt;N\u0026gt;.dex according to the multi-DEX feature of the original APK. These DEX files are not exactly the original ones, as their Dalvik bytecode have been NOP-ed by Legu. Therefore, a dump of these files only gives information about the classes' names, not the code logic:\nThen follows what we called a hashmap that is used to link a class name (e.g. Lcom/tencent/mmkv/MMKV;) to an offset in the data block located in the third part of the file. This data block contains the original Dalvik bytecode of the methods.\nActually, the first part that contains the altered DEX files, is compressed with NRV 1. The second part — the hashmap — is also compressed with NRV but the packer adds a layer of encryption through a slightly modified version of XTEA 2. Finally, the last part is compressed and encrypted with the same algorithms as the previous one.\nRegarding the hashmap, it uses a custom structure that has been reversed and lead to a Kaitai structure available here: legu_packed_file.ksy, legu_hashmap.ksy\nIts overall layout is exposed in the next figure:\nUnpacking process Let\u0026rsquo;s say that the application needs to use the packed Java class Lcom/tencent/mmkv/MMKV;.\nFirst, the packer\u0026rsquo;s runtime transforms the class name into an integer with the dvmComputeUtf8Hash() hash function 3. This integer is then used as an index into the hashmap whose value is a structure that contains information about the class in the packed data (blue area in the figure). The first attribute of this structure — utf8_hash — is a copy of the hash value which is used to check that it is the right key/value association.\nThe class_info structure (blue block in the figure) next contains the packed method information (yellow area in the figure) whose size is the same as the original number of methods in the class. This structure makes the relationship between the NOP-ed bytecode offset in the altered DEX files and the offset in the original bytecode (red block). Finally, the packer copies the original bytecode into the altered DEX files.\nTo summarize, the first part contains the original DEX files with the Dalvik bytecode removed (NOP-ed). The last part contains the missing Dalvik bytecode and the second part makes the bridge between the altered DEX files and the Dalvik bytecode.\nCompression \u0026amp; Encryption To decrypt the hashmap and the Dalvik bytecode, the packer uses the first 16 bytes of assets/tosversion xored with a hard-coded key: ^hHc7Ql]N9Z4:+1m~nTcA\u0026amp;3a7|?GB1z@.\nLIB_KEY = b\u0026#34;^hHc7Ql]N9Z4:+1m~nTcA\u0026amp;3a7|?GB1z@\u0026#34; def key_derivation(key: bytes) -\u0026gt; bytes: return bytes(x1 ^ x2 for x1, x2 in zip(LIB_KEY, cycle(key))) Then, it uses a slightly modified version of XTEA that is given in the next listing:\nint xtea_decrypt(uint32_t* key, uint32_t* buf, size_t ilen, size_t nb_round) { const size_t count = ilen / 8; const size_t key_off = (ilen \u0026amp; 8) / 4; static constexpr uint32_t DELTA = 0x9e3779b9; const uint32_t key_0 = key[key_off + 0]; const uint32_t key_1 = key[key_off + 1]; for (size_t i = 0; i \u0026lt; count * 2; i += 2) { buf[i + 0] ^= key_0; buf[i + 1] ^= key_1; uint32_t sum = DELTA * nb_round; uint32_t temp0 = buf[i + 0]; uint32_t temp1 = buf[i + 1]; for (size_t j = 0; j \u0026lt; nb_round; ++j) { temp1 -= (key[2] + (temp0 \u0026lt;\u0026lt; 4)) ^ (key[3] + (temp0 \u0026gt;\u0026gt; 5)) ^ (temp0 + sum); temp0 -= (key[0] + (temp1 \u0026lt;\u0026lt; 4)) ^ (key[1] + (temp1 \u0026gt;\u0026gt; 5)) ^ (temp1 + sum); sum -= DELTA; } buf[i + 0] = temp0; buf[i + 1] = temp1; } return 0; } After the decryption routine, the packer decompresses the data with NRV, the same algorithm used to compress the altered DEX files:\nkey = key_derivation(open(\u0026#34;assets/tosversion\u0026#34;, \u0026#34;rb\u0026#34;).read()[:16]) for i in range(nb_dex_files): hashmap[i] = nrv_decompress(xtea_decrypt(blob1, key)) dalvik_bytecodes[i] = nrv_decompress(xtea_decrypt(blob2, key)) Unpacking Putting all the pieces together, we can statically unpack protected APKs and recover the original bytecode:\nHence, as we can automatically unpack such APKs, the unpacking process could be integrated into an automatic analysis pipeline.\nThe script and the Kaitai structures are available on the Quarkslab\u0026rsquo;s repository: legu_unpacker_2019, along with a suspicious application 4, packed and unpacked.\nAcknowledgments Thanks to my colleagues who proofread this article.\nReferences   http://www.oberhumer.com/opensource/ucl/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/XTEA\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n http://androidxref.com/4.4.4_r1/xref/dalvik/vm/UtfString.cpp#88\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://www.virustotal.com/gui/file/708e6967920dcf2789b7183d714e73ab79a2f8b3ca71929b12aadeb2c58c2867/detection\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1574726400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1574726400,"objectID":"a2bb3b32975c74e42cac7b55165ddd60","permalink":"/post/a-glimpse-into-tencents-legu-packer/","publishdate":"2019-11-26T00:00:00Z","relpermalink":"/post/a-glimpse-into-tencents-legu-packer/","section":"post","summary":"Analysis of Tencent Legu: a packer for Android applications.","tags":["android","reverse engineering","packer"],"title":"A Glimpse Into Tencent's Legu Packer","type":"post"},{"authors":["Romain Thomas"],"categories":["Android","Reverse Engineering"],"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s Blog   Introduction During the past few months we improved the ARM support in QBDI. More precisely, we enhanced the QBDI\u0026rsquo;s engine to support Thumb and Thumb2 instructions as well as Neon registers.\nDevelopment is still in progress and we need to clean the code and add non-regression tests compared to the x86-64 support.\nTo add Thumb and Thumb2 support, we tested the DBI against well-known obfuscators such as Epona, O-LLVM or Arxan, as we could expect good instruction coverage, corner cases and nice use cases. The native code came from Android JNI libraries embedded in different APKs.\nThis blog post introduces some QBDI features that could be useful to assess native code and speedup reverse engineering. To expose these features, we analyzed an Android SDK that aims to protect applications against API misuse.\nDynamic Instrumentation on Android  Frida is one of the Android day-to-day dynamic instrumentation framework widely used to instrument applications. It can address both native code with inline hooking and Java side thanks to ART instrumentation 1.\nFrida works at the function level and in some cases we may need to have a finer granularity at the basic-block level or at the instruction level (i.e. have hooks on instructions)\nTo address this limitation, one trick commonly used is to combine hooking with emulation. One can use Frida to hook the function that we are interested in, then we can dump the CPU context and the memory state of the process and eventually continue the execution through an emulator like Miasm or Unicorn\nThis approach works pretty well but has a few limitations:\n Speed: For large sets of functions. External calls: One needs to mock external calls behavior (e.g. strlen, malloc, \u0026hellip;). Some behaviors can be difficult to emulate: Thread, Android internal frameworks, \u0026hellip;  Moreover, while it is quite simple to mock the behavior of strlen, it may be more challenging to mock JNI functions behavior like FindClass(), GetMethodID(), RegisterNatives(), \u0026hellip;\nThe design of QBDI provides a good trade-off between full instrumentation and partial emulation thanks to the ExecBrocker that enables to switch between instrumented code — our function — and non-instrumented code: strlen(), FindClass(), pthread_call_once(), \u0026hellip;\nThis diagram represents the instrumentation flow for the different scenarios:\nFor those who are interested in QBDI internals you can look at the 34C3 talk by Charles and Cédric 2. There are also examples in the GitHub repository 3.\nTo summarize, we can bootstrap QBDI as follows:\n// QBDI main interface QBDI::VM vm; // QBDI CPU state for GPR registers GPRState* state = vm.getGPRState(); // Setup virtual stack uint8_t *fakestack = nullptr; QBDI::allocateVirtualStack(state, /* size */0x100000, \u0026amp;fakestack); // { // Setup instrumentation ranges, callbacks etc, ... // }  // Start Instrumentation: uintptr_t retval; bool ok = vm.call(\u0026amp;retval, /* Address of the function to instrument */); // Instrumentation Finished SDK Overview Among the QBDI tests, we analyzed an SDK that aims to protect applications against API abuses. This kind of protection is used to protect API endpoints against illegitimate uses: emulator, bots, \u0026hellip;\nTo protect the main application, the solution collects information about the device state: rooted, debugged, custom, then encodes this information with a proprietary algorithm and sends the encoded data to a server.\nThe server decodes the information sent by the device collector, performs analyses to check the device integrity and sends back a token that handles the information about whether the device is corrupted or not.\nThe following figure summarizes this process:\nSuch architecture is robust and similar to the one in Safetynet 4. On the other hand, the SDK has fewer permissions than Safetynet, therefore it cannot collect as much data about the device as SafetyNet does.\nWe started the analysis by monitoring the network traffic between the SDK and its server. At some point, we can observe the following request:\nIt is JSON encoded and the characters that look like random values are the encoded information sent by the device collector.\nThe analysis of the SDK aims to address these questions:\n How the SDK checks if the device is rooted or not ? How the SDK detects if the application is being debugged ? What kind of information is collected from the device and how it is encoded ?  After a look at the Java layer, we found that the logic of the solution is implemented in a JNI library that will be named libApp.so 5. The library exposes the following JNI functions:\n! \nWith static analysis, we can identify that the function Java_XXX_JNIWrapper_ca3_14008() is the one involved in the generation of the sequence \u0026quot;QJRR{JJJGQJ~|MJJJ...\u0026quot;. It returns the encoded data as a java.lang.String and takes two parameters that are not mandatory: bArr, iArr 6.\nThe library as a whole is not especially obfuscated. Nonetheless, we find strings encoding and syscall replacement on well-known libc functions:\n read openat close \u0026hellip;  This technique is commonly used to avoid hooking but the fact is that the given syscalls are wrapped in functions that are not inlined. Hence, one can hook the functions that wrap the associated syscall.\nGet Started with QBDI In order to fully understand the logic of this function, we instrumented the function through QBDI 7 associated with a set of instrumentation callbacks.\nThese callbacks aim to provide different kinds of information that will be useful to the analyst to understand the function logic. For instance, we can setup a first callback that records all the syscall instructions, we can also add a callback that records memory access.\nThe purpose of this blog post is to show how few — but well chosen — callbacks enable to understand the logic of the function.\nFirst of all, the native library embedded in the SDK can be loaded outside of the original APK using dlopen() / dlsym(). Moreover, one can instantiate a JVM thanks to the ART runtime (libart.so):\nint main(int argc, char** argv) { static constexpr const char* TARGET_LIB = \u0026#34;libApp.so\u0026#34;; void* hdl = dlopen(TARGET_LIB, RTLD_NOW); using jni_func_t = jstring(*)(JNIEnv* /* Other parameters are not required */); auto jni_func = reinterpret_cast\u0026lt;jni_func_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14008\u0026#34;)); JavaVM* jvm, JNIEnv* env; ART_Kitchen(jvm, env); // Instantiate the JVM and initialize the jvm and env pointers } At this point, the jni_func() function is tied to Java_XXX_JNIWrapper_ca3_14008 and ready to be executed in main():\njstring output = jni_func(env); const char* cstring = env-\u0026gt;GetStringUTFChars(output, nullptr); console-\u0026gt;info(\u0026#34;Real Output: {}\u0026#34;, cstring); The output seems consistent with the network capture and the value \u0026quot;root: 1\u0026quot; too since we are on a rooted device 8\nNow, let\u0026rsquo;s run the function through QBDI:\nconsole-\u0026gt;info(\u0026#34;Initializing VM ...\u0026#34;); QBDI::VM vm; GPRState* state = vm.getGPRState(); uint8_t *fakestack = nullptr; QBDI::allocateVirtualStack(state, 0x100000, \u0026amp;fakestack); console-\u0026gt;info(\u0026#34;Instument module: {}\u0026#34;, TARGET_LIB); vm.addInstrumentedModule(TARGET_LIB); console-\u0026gt;info(\u0026#34;Simulate call in QBDI\u0026#34;); jstring dbioutput; bool ok = vm.call(\u0026amp;dbioutput, reinterpret_cast\u0026lt;rword\u0026gt;(jni_func), {reinterpret_cast\u0026lt;rword\u0026gt;(env)}); if (ok and dbioutput != nullptr) { console-\u0026gt;info(\u0026#34;DBI output {:x}\u0026#34;, env-\u0026gt;GetStringUTFChars(dbioutput, nullptr)); } This code provides the following output:\nEverything looks good, QBDI managed to fully instrument the function (which includes ARM / Thumb switch) and the result is similar to the real execution.\nAnalysis Now that we are able to run and instrument the function, we can start to add instrumentation callbacks to analyze its behavior.\nOne of the first callbacks that is useful to setup is a callback that instruments syscall instructions (i.e. svc #0). To do so, we can use the vm.addSyscallCB(position, callback, data).\n position - It stands for the position of the callback: Before or after the syscall. callback - The callback itself. data - Pointer to user data (e.g. user context that register dynamic information)  It leads to the following piece of code:\nauto syscall_enter_cbk = [] (VMInstanceRef vm, GPRState *gprState, FPRState *fprState, void *data) { const InstAnalysis* analysis = vm-\u0026gt;getInstAnalysis(ANALYSIS_INSTRUCTION | ANALYSIS_DISASSEMBLY); rword syscall_number = gprState-\u0026gt;r7; /* * std::string sys_str = lookup[syscall_number]; // Lookup table that convert syscall number to function */ console-\u0026gt;info(\u0026#34;0x{:06x} {} ({})\u0026#34;, addr, analysis-\u0026gt;disassembly, sys_str); return VMAction::CONTINUE; } vm.addSyscallCB(PREINST, syscall_enter_cbk, /* data */ nullptr); Before any syscall instructions, we perform a basic lookup on the syscall number stored in the R7 register to resolve its name.\nIt results in the following output:\nSince we are able to resolve syscall numbers into function names, we can improve the logic of callback to dispatch and print function parameters:\nauto syscall_enter_cbk = [] (...) { ... /* * Lookup table (syscall number, function pointer) * { * 322 -\u0026gt; on_openat * } */ auto function_wrapper = func_lookup[syscall_number]; return function_wrapper(...) } // Wrapper for openat syscall VMAction on_openat(VMInstanceRef vm, GPRState *gprState, ...) { auto path = reinterpret_cast\u0026lt;const char*\u0026gt;(gprState-\u0026gt;r1); console-\u0026gt;info(\u0026#34;openat({})\u0026#34;, path); return VMAction::CONTINUE; } By doing so on the common syscalls number, we get this new trace:\nBased on this output, we can figure out how root check (orange area) is done. It is performed by checking the existence of the following binaries:\n /system/bin/su /system/xbin/su /sbin/su \u0026hellip;  The function also checks if some directories are present on the device (faccessat syscall):\n /data /tmp /system \u0026hellip;  Especially, it would be suspicious if the directory /tmp were present on the device while it is standard to have /system and /data directories.\nRegarding the debug state of the process (blue area), it is done by looking at /proc/self/status. After analysis, the function checks the TracerPID attribute (cf More Android Anti-Debugging Fun - B. Mueller)\nFinally, the function processes the output of /proc/self/maps right before to returning the encoded values. It suggests that the data collected by the solution are based on this resource.\nEncoding Routine In the previous part we got a global overview about how the solution achieves root detection, debug detection and what kind of data is collected (i.e. process memory map).\nHowever, some questions are pending:\n What part of the process memory map is used: Base addresses ? Module paths ? Permissions ? How the data are encoded (i.e. how QJRR{JJJGQJ~|MJJJ... is generated) ?  Along with the QBDI ARM support, we also added ARM support to resolve memory addresses during the instrumentation. It means that QBDI is now able to resolve the effective memory address of instructions such as:\nLDR R0, [R1, R2]; # Resolve R1 + R2 STR R1, [R2, R3, LSL #2]; # Resolve R2 + R3 * 4 LDRB [PC, #4]; # Resolve **real** PC + 4 Moreover, QBDI is also able to get the effective memory value that is read or written. This feature is quite useful in the case of conditional instructions such as:\nITT LS; LDRLS R0, [R4]; LDRLS R1, [R0, #4] The effective value of R0 and R1 is stored in QBDI. It may not be *(r4) and *(r0 + 4) since the LS condition may not be verified.\nTo add a callback on memory accesses, we can use the addMemAccessCB(...) function on the VM instance:\nvm.addMemAccessCB(MEMORY_READ_WRITE, memory_callback, /* data */ nullptr); In the given memory_callback(...) function, we perform the following actions:\n Track memory byte accesses. Check if the value is printable. Pretty print the R/W value.  The idea of this callback is to track memory accesses that are performed on printable characters. It enables to quickly identify strings encoding/decoding routines.\nHere is the implementation of the callback:\nVMAction memory_callback(VMInstanceRef vm, GPRState *gprState, ...) { auto\u0026amp;\u0026amp; acc = vm-\u0026gt;getInstMemoryAccess(); // Get last memory access  MemoryAccess maccess = acc.back(); // Retrieve access information:  rword addr = maccess.accessAddress; // Address accessed  rword value = maccess.value; // Value read or written  rword size = maccess.size; // Access size  // Only look for byte access  if (size != sizeof(char)) { return VMAction::CONTINUE; } // Read / Write operation as a string  const std::string kind = maccess.type == MemoryAccessType::MEMORY_READ ? \u0026#34;[R]\u0026#34; : \u0026#34;[W]\u0026#34;; // Cast the value into a char  const char cvalue = static_cast\u0026lt;char\u0026gt;(value); // Check if the value read or written is printable  if (::isprint(cvalue)) { logger-\u0026gt;info(\u0026#34;0x{:x} {}: {}\u0026#34;, addr, kind, cvalue); // Pretty print  } // Continue this execution  return VMAction::CONTINUE; } With this new callback, we can observe such output between two openat() syscalls involved in the root check routine:\nIt is basically the string decoding routine in action. Note that some read operations are missing since we only track printable characters. However all write operations are present.\nThe routine loads characters with the instruction at address 0x295e and stores the decoded value at address 0x2972. If we look at the function that handles these two addresses, we find the decoding routine:\nIn the above figure, the green section highlights the memory load access while the red one highlights the write operation. The blue area is the decoding logic.\nThe output of all read / write accesses turns out to be quite verbose on the whole execution of the function. We can improve the instrumentation by adding two callbacks before and after function calls with this purpose:\n Before calls, we print the target address (e.g. 0x123: blx r3 -\u0026gt; .text!0xABC). After calls we print all printable characters being read or written within the called function.  The addCallCB(...) is still in experimentation but it aims to put callbacks before or after call instructions:\n// Callback before ``call`` instructions vm.addCallCB(PRECALL, on_call_enter, nullptr); // Callback when a ``call`` returns vm.addCallCB(POSTCALL, on_call_exit, nullptr); With these two callbacks we get the following output:\nBy going further in the memory trace, we can observe this output:\nFrom this output we can infer the behavior of the collector (pseudo-code):\nf = open(\u0026#34;/proc/self/maps\u0026#34;) for line in f.readlines(): if not \u0026#34;/\u0026#34; in line: # Avoid entries such as XXX-YYY ... [anon:linker_alloc] continue if not \u0026#34;-xp\u0026#34; in line # Process executable segments only continue buffer += encode(line) We can also observe a sequence of\n READ line[i] CALL .text!0xd2ba WRITE encoded(line[i])  It suggests that the logic of the encode() function is implemented at address 0xd2ba.\nThe CFG of this function is compounded by instructions that compare the input against magic printable values and we manually checked that it is the encoding function. Moreover this function is — by design — reversible since the server side algorithm needs to process the encoded data.\nLibrary lifting In the previous parts, we targeted the ARM version of the library. It turns out that SDKs which use native libraries usually provide the libraries for all architectures (arm, arm64, x86, x86-64).\nIndeed, they do not want to limit developers to some architectures. The solution previously analyzed also comes with a x86-64 version of libApp.so with the exact same interface.\nMoreover, the analysis done in the previous sections shows that there are no real dependencies to the Android system:\n Syscall are standards and available on Linux. /proc/self/maps and /proc/self/status are available on Linux.  Thus, we can lift the library and run it on Linux. This technique has already been described in this blog post: When SideChannelMarvels meet LIEF.\nIn a first step, we have to patch the library with LIEF:\nimport lief libApp = lief.parse(\u0026#34;libApp.so\u0026#34;) # Patch library names # =================== libApp.get_library(\u0026#34;libc.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; libApp.get_library(\u0026#34;liblog.so\u0026#34;).name = \u0026#34;libc.so.6\u0026#34; libApp.get_library(\u0026#34;libm.so\u0026#34;).name = \u0026#34;libm.so.6\u0026#34; libApp.get_library(\u0026#34;libdl.so\u0026#34;).name = \u0026#34;libdl.so.2\u0026#34; # Patch dynamic entries # ===================== # 1. Remove ELF constructors libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAY].array = [] libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAY].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.INIT_ARRAYSZ].value = 0 libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAY].array = [] libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAY].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.FINI_ARRAYSZ].value = 0 # 2. Remove symbol versioning libApp[lief.ELF.DYNAMIC_TAGS.VERNEEDNUM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERNEED].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERDEFNUM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERDEF].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp[lief.ELF.DYNAMIC_TAGS.VERSYM].tag = lief.ELF.DYNAMIC_TAGS.DEBUG libApp.write(\u0026#34;libApp-x86-64.so\u0026#34;) Then, we can instantiate a Linux JVM and run the native function:\nint main() { JavaVM *jvm = nullptr; JNIEnv* env = nullptr; // JVM options  JavaVMOption opt[1]; JavaVMInitArgs args; ... // JVM instantiation  JNI_CreateJavaVM(\u0026amp;jvm, reinterpret_cast\u0026lt;void**\u0026gt;(\u0026amp;env), \u0026amp;args); // Load the library  void* hdl = dlopen(\u0026#34;libApp-x86-64.so\u0026#34;, RTLD_LAZY | RTLD_LOCAL); // Resolve the functions  using abi_t = jint(*)(JNIEnv*); using jni_func_t = jstring(*)(JNIEnv*); auto\u0026amp;\u0026amp; jni_get_abi = reinterpret_cast\u0026lt;abi_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14007\u0026#34;)); auto\u0026amp;\u0026amp; jni_func = reinterpret_cast\u0026lt;jni_func_t\u0026gt;(dlsym(hdl, \u0026#34;Java_XXX_JNIWrapper_ca3_14008\u0026#34;)); // Execute  jint abi = jni_get_abi(env); console-\u0026gt;info(\u0026#34;ABI: {:d}\u0026#34;, abi); jstring encoded = jni_func(env); console-\u0026gt;info(\u0026#34;ca3_14008(): {}\u0026#34;, env-\u0026gt;GetStringUTFChars(encoded, nullptr)); return EXIT_SUCCESS; } By executing this code, we get a similar output as seen in the previous parts:\nWe can also run the strace utility to inspect the syscalls:\nSince we are able to run the function on Linux, we could also use gdb, Intel PIN or QBDI(x86-64) to analyze the library.\nConclusion While it has been quite challenging to add the whole ARM support in QBDI, it starts to work pretty well on real use cases. Such support should also lead to interesting applications among which:\n HongFuzz / QBDI for Android.  SideChannelMarvels integration for CPA attacks. Trustlets instrumentation.  The raw traces used in this blog post are available here: traces.zip \u0026lt;resources/2019-06-15-android-jni-library-p1/traces.zip\u0026gt;_\nAcknowledgments Many thanks to Charles Hubain and Cédric Tessier who developed and designed QBDI. It is really pleasant to work on the concepts involved in this DBI.\nThanks to the LLVM community to provide such framework without which this project would not be possible.\nThanks to my Quarkslab colleagues who proofread this article.\nReferences   Frida modifies fields of the art::ArtMethod object associated with the Java method.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  Slides - Talk\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/QBDI/QBDI/blob/master/examples\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n DroidGuard being the SafetyNet module that collects information about the device.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The name has been intentionally changed.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Plus the this parameter which is a jclass object for a static method.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Even though static analysis would be enough in this case.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Nexus 5X - Android 8.1.0 - Rooted with Magisk.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":155952e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":155952e4,"objectID":"80507e111d02e96ebba18f081a8df969","permalink":"/post/android-native-library-analysis-with-qbdi/","publishdate":"2019-06-03T00:00:00Z","relpermalink":"/post/android-native-library-analysis-with-qbdi/","section":"post","summary":"This blog post deals with QBDI and how it can be used to reverse an Android JNI library","tags":["android","qbdi"],"title":"Android Native Library Analysis with QBDI","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"PoC that demonstrates how to disable runtime restrictions (hidden-api and dlopen namespaces) in user-land.\n  https://github.com/quarkslab/android-restriction-bypass  ","date":1553644800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553644800,"objectID":"d539026e0a71b974dd820beadbc99bf0","permalink":"/project/android-runtime-restrictions-bypass/","publishdate":"2019-03-27T00:00:00Z","relpermalink":"/project/android-runtime-restrictions-bypass/","section":"project","summary":"Android application that disables Android restrictions without root privileges","tags":["android"],"title":"Android Runtime Restrictions Bypass (PoC)","type":"project"},{"authors":["Romain Thomas"],"categories":null,"content":" This publication is also available on the Quarkslab Blog.   With the release of Android Nougat, Google introduced restriction about native libraries that can be loaded from an Android application. Basically, it prevents developers to link against some internal libraries such as libart.so.\nLater on and with the release of Android Pie, they introduced a new restriction on the access to internal Java methods (or fields). Basically, these restrictions are used to prevent developers to access parts of the Android internal framework.\nWhereas these limitations aim to be used for compatibility purposes, this article shows how we can take advantage of Android internal to disable them. We briefly explain how these restrictions work and how to disable them from an application without privileges.\nThe first part deals with the native library loading restriction while the second is about Java internal framework restriction.\n ","date":1553299200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553299200,"objectID":"f66d0c032de15b286b9719768258637a","permalink":"/publication/android-restrictions-bypass/","publishdate":"2019-03-23T00:00:00Z","relpermalink":"/publication/android-restrictions-bypass/","section":"publication","summary":"This paper explains how to disable runtime restrictions without root privileges","tags":null,"title":"Android Runtime Restrictions Bypass","type":"publication"},{"authors":[],"categories":[],"content":"Welcome to Slides  Academic\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click  PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/img/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions?  Ask\n Documentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["Romain Thomas"],"categories":["Android","Challenge"],"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s Blog   Here is an Android crackme developed for the Android training given at Quarkslab.\nThe objective is to find the correct phone number that leads to the following message:\nThe application can be run on an emulator or a real device (whatever the architecture) but the Android version must be at least Marshmallow (\u0026gt; 6.0).\n crackme-telegram.apk - SHA256: d66b82ebc14708b214a581760e99894af17e10598bcef95e75441a12b948bbf0\n","date":1542672e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1542672e3,"objectID":"d724397d35a350dc535a41153c0ffe34","permalink":"/post/android-crackme/","publishdate":"2018-11-20T00:00:00Z","relpermalink":"/post/android-crackme/","section":"post","summary":"Android crackme that uses system's internals","tags":["android","challenge","crackme"],"title":"Android crackme challenge","type":"post"},{"authors":["Romain Thomas"],"categories":["Android"],"content":"Here are internal structures of Android OAT:\nOAT 124  PDF Version\nOAT 79  PDF Version\nOAT 64  PDF Version\n","date":1529884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1529884800,"objectID":"cafaa1cdcbc4a0c195df4fe91329d011","permalink":"/post/android-oat/","publishdate":"2018-06-25T00:00:00Z","relpermalink":"/post/android-oat/","section":"post","summary":"Internal structures of OAT format","tags":["android","oat"],"title":"Android OAT formats","type":"post"},{"authors":["Romain Thomas"],"categories":["Android"],"content":"Here are internal structures of Android VDEX:\nVDEX 10  PDF Version\nVDEX 06  PDF Version\n","date":1529884800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1529884800,"objectID":"0253840aba4cfb0a98dbd91c16c8b583","permalink":"/post/android-vdex/","publishdate":"2018-06-25T00:00:00Z","relpermalink":"/post/android-vdex/","section":"post","summary":"Internal structures of VDEX format","tags":["android","vdex","format"],"title":"Android VDEX formats","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Many instrumentation techniques are based on modifying code or system environment of the target. It can be suitable for scenarios but it could not work under certain circumstance (integrity checking, non-rooted environment…) In this talk we propose similar techniques by only modifying the executable format. This enables to be architecture independent, injection and hooking does not require privileged environment.\nTalk given at Recon Montréal and Pass The Salt\n ","date":1529452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1529452800,"objectID":"8ad68419c7751ad4bcd1540adbaf29a9","permalink":"/publication/static-instrumentation/","publishdate":"2018-06-20T00:00:00Z","relpermalink":"/publication/static-instrumentation/","section":"publication","summary":"Talk given at Recon Montréal and PassTheSalt18 about static instrumentation and its use cases.","tags":null,"title":"Static Instrumentation Based on Executable Formats","type":"publication"},{"authors":["Philippe Teuwen","Romain Thomas"],"categories":["LIEF","Reverse Engineering"],"content":"","date":1525305600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1525305600,"objectID":"8ca02704ae443314f551cbe328452bf9","permalink":"/post/when-sidechannelmarvels-meet-lief/","publishdate":"2018-05-03T00:00:00Z","relpermalink":"/post/when-sidechannelmarvels-meet-lief/","section":"post","summary":"On how we used LIEF to lift an Android ``x86-64`` library to Linux to perform our usual white-box attacks on it.","tags":["lief","whitebox"],"title":"When SideChannelMarvels meet LIEF","type":"post"},{"authors":["Romain Thomas"],"categories":["LIEF","Android"],"content":"This post is a part of LIEF tutorials. It explains how to combine Frida and LIEF to run frida-gadget on a non rooted device.\n See more\n","date":1520035200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1520035200,"objectID":"07879a4dd6943de00d78e7d1ff0f0307","permalink":"/post/how-to-use-frida-on-a-non-rooted-device/","publishdate":"2018-03-03T00:00:00Z","relpermalink":"/post/how-to-use-frida-on-a-non-rooted-device/","section":"post","summary":"This post explains how to use Frida gadget on a non-rooted device.","tags":["lief"],"title":"How to use frida on a non-rooted device","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"","date":1517616e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1517616e3,"objectID":"c2685e99cafabf39cc82e6dcc2ef3c2a","permalink":"/post/transforming-an-elf-executable-into-a-library/","publishdate":"2018-02-03T00:00:00Z","relpermalink":"/post/transforming-an-elf-executable-into-a-library/","section":"post","summary":"This post explains how to use LIEF to transform an ELF executable into a library","tags":["lief"],"title":"Transforming an ELF executable into a library","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"","date":1509577200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1509577200,"objectID":"c3fb2186f7a376c8c0c62177f6906f67","permalink":"/post/have-fun-with-lief-and-executable-formats/","publishdate":"2017-11-02T00:00:00+01:00","relpermalink":"/post/have-fun-with-lief-and-executable-formats/","section":"post","summary":"This blog post introduces new features of LIEF as well as some uses cases.","tags":["lief"],"title":"Have fun with LIEF and Executable Formats","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"When analyzing executable, the first layer of information is the format in which the executable is wrapped. It turns out that a lot of tools and libraries exist to analyze and instrument machine code wrapped by the format, but there is not such library to handle the three mainstream executable formats and to both read and modify these formats. LIEF has been developed to that end.\nIn the talk we will explain the rationale behind LIEF architecture choices, what LIEF allows to do and have a look at use cases.\nLIEF is a cross platform library and it can be used through a Python, C++ and C API. The library enables to parse standard structures as well as more complex ones like PE Signature (Authenticode) and ELF hash table. As use cases we can inject code into a binary or a library, we can also redirect the control flow to hook functions and it can be used to obfuscate some parts of a binary. Another feature of LIEF is that common characteristics of these formats are factorized so that we can develop a single script which works for the three formats.\n Slides of the talk given at RMLL  You can also grab the slides of the talk given at Cybersecurity France-Japan: 17-04-cybersecurity-frjp-LIEF.pdf\n","date":1499126400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1499126400,"objectID":"b4e3c965220814581b363ec08db9d7ae","permalink":"/publication/lief/","publishdate":"2017-07-04T00:00:00Z","relpermalink":"/publication/lief/","section":"publication","summary":"When analyzing executable, the first layer of information is the format in which the executable is wrapped. It turns out that a lot of tools and libraries exist to analyze and instrument machine code wrapped by the format, but there is not such library to handle the three mainstream executable formats and to both read and modify these formats. LIEF has been developed to that end.\nIn the talk we will explain the rationale behind LIEF architecture choices, what LIEF allows to do and have a look at use cases.","tags":null,"title":"LIEF: Library to Instrument Executable Formats","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":" This post has been originally posted on the Quarkslab\u0026rsquo;s blog   Executable File Formats in a Nutshell When dealing with executable files, the first layer of information is the format in which the code is wrapped. We can see an executable file format as an envelope. It contains information so that the postman (i.e. Operating System) can handle and deliver (i.e. execute) it. The message wrapped by this envelope would be the machine code.\nThere are mainly three mainstream formats, one per OS:\n Portable Executable (PE) for Windows systems Executable and Linkable Format (ELF) for UN*X systems (Linux, Android\u0026hellip;). Mach-O for OS-X, iOS\u0026hellip;  Other executable file formats, such as COFF, exist but they are less relevant.\nUsually each format has a header which describes at least the target architecture, the program\u0026rsquo;s entry point and the type of the wrapped object (executable, library\u0026hellip;) Then we have blocks of data that will be mapped by the OS\u0026rsquo;s loader. These blocks of data could hold machine code (.text), read-only data (.rodata) or other OS specific information.\nFor PE there is only one kind of such block: Section. For ELF and Mach-O formats, a section has a different meaning. In these formats, sections are used by the linker at the compilation step, whereas segments (second type of block) are used by the OS\u0026rsquo;s loader at execution step. Thus sections are not mandatory for ELF and Mach-O formats and can be removed without affecting the execution.\nPurpose of LIEF It turns out that many projects need to parse executable file formats but don\u0026rsquo;t use a standard library and re-implement their own parser (and the wheel). Moreover, these parsers are usually bound to one language.\nOn Unix system one can find the objdump and objcopy utilities but they are limited to Unix and the API is not user-friendly.\nThe purpose of LIEF is to fill this void:\n Providing a cross platform library which can parse and modify (in a certain extent) ELF, PE and Mach-O formats using a common abstraction Providing an API for different languages (Python, C++, C\u0026hellip;) Abstract common features from the different formats (Section, header, entry point, symbols\u0026hellip;)  The following snippets show how to obtain information about an executable using different API of LIEF:\nimport lief # ELF binary = lief.parse(\u0026#34;/usr/bin/ls\u0026#34;) print(binary) # PE binary = lief.parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;) print(binary) # Mach-O binary = lief.parse(\u0026#34;/usr/bin/ls\u0026#34;) print(binary) With the C++ API:\n#include \u0026lt;LIEF/LIEF.hpp\u0026gt; int main(int argc, const char** argv) { LIEF::ELF::Binary* elf = LIEF::ELF::Parser::parse(\u0026#34;/usr/bin/ls\u0026#34;); LIEF::PE::Binary* pe = LIEF::PE::Parser::parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;); LIEF::MachO::Binary* macho = LIEF::MachO::Parser::parse(\u0026#34;/usr/bin/ls\u0026#34;); std::cout \u0026lt;\u0026lt; *elf \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; *pe \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; *macho \u0026lt;\u0026lt; std::endl; delete elf; delete pe; delete macho; } And finally with the C API:\n#include \u0026lt;LIEF/LIEF.h\u0026gt; int main(int argc, const char** argv) { Elf_Binary_t* elf_binary = elf_parse(\u0026#34;/usr/bin/ls\u0026#34;); Pe_Binary_t* pe_binary = pe_parse(\u0026#34;C:\\\\Windows\\\\explorer.exe\u0026#34;); Macho_Binary_t** macho_binaries = macho_parse(\u0026#34;/usr/bin/ls\u0026#34;); Pe_Section_t** pe_sections = pe_binary-\u0026gt;sections; Elf_Section_t** elf_sections = elf_binary-\u0026gt;sections; Macho_Section_t** macho_sections = macho_binaries[0]-\u0026gt;sections; for (size_t i = 0; pe_sections[i] != NULL; ++i) { printf(\u0026#34;%s\\n\u0026#34;, pe_sections[i]-\u0026gt;name) } for (size_t i = 0; elf_sections[i] != NULL; ++i) { printf(\u0026#34;%s\\n\u0026#34;, elf_sections[i]-\u0026gt;name) } for (size_t i = 0; macho_sections[i] != NULL; ++i) { printf(\u0026#34;%s\\n\u0026#34;, macho_sections[i]-\u0026gt;name) } elf_binary_destroy(elf_binary); pe_binary_destroy(pe_binary); macho_binaries_destroy(macho_binaries); } LIEF supports FAT-MachO and one can iterate over binaries as follows:\nimport lief binaries = lief.MachO.parse(\u0026#34;/usr/lib/libc++abi.dylib\u0026#34;) for binary in binaries: print(binary)  The above script uses the lief.MachO.parse function instead of the lief.parse function because lief.parse returns a single lief.MachO.binary object whereas lief.MachO.parse returns a list of lief.MachO.binary (according to the FAT-MachO format).   Along with standard format components like headers, sections, import table, load commands, symbols, etc. LIEF is also able to parse PE Authenticode:\nimport lief driver = lief.parse(\u0026#34;driver.sys\u0026#34;) for crt in driver.signature.certificates: print(crt) Version: 3 Serial Number: 61:07:02:dc:00:00:00:00:00:0b Signature Algorithm: SHA1_WITH_RSA_ENCRYPTION Valid from: 2005-9-15 21:55:41 Valid to: 2016-3-15 22:5:41 Issuer: DC=com, DC=microsoft, CN=Microsoft Root Certificate Authority Subject: C=US, ST=Washington, L=Redmond, O=Microsoft Corporation, CN=Microsoft Windows Verification PCA ... Full API documentation is available here\n  Python API  C++ API  C API  Architecture In the LIEF architecture, each format implements at least the following classes:\n Parser: Parse the format and decompose it into a Binary class Binary: Modelize the format and provide an API to modify and explore it. Builder: Transform the binary object into a valid file.    To factor common characteristics in formats we have an inheritance relationship between these characteristics.\nFor symbols it gives the following diagram:\n  It enables to write cross-format utility like nm. nm is a Unix utility to list symbols in an executable. The source code is available here: binutils\nWith the given inheritance relationship one can write this utility for the three formats in a single script:\nimport lief import sys def nm(binary): for symbol in binary.symbols: print(symbol) return 0 if __name__ == \u0026#34;__main__\u0026#34;: r = nm(sys.argv[1]) sys.exit(r) Conclusion As LIEF is still a young project we hope to have feedback, ideas, suggestions and pull requests.\nThe source code is available here: https://github.com/lief-project (under Apache 2.0 license) and the associated website: http://lief.quarkslab.com\nIf you are interested in use cases, you can take a look at these tutorials:\n  Parse and manipulate formats  Create a PE from scratch  Play with ELF symbols  Hooking  Infecting the PLT/GOT  The project will be presented at the Third French Japanese Meeting on Cybersecurity\nContact  lief [at] quarkslab [dot] com Gitter: lief-project  Thanks Thanks to Serge Guelton and Adrien Guinet for their advice about the design and their code review. Thanks to Quarkslab for making this project open-source.\n","date":1491256800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1491256800,"objectID":"b9bd4190cd2fa4a30e4a6592ed242529","permalink":"/post/lief-release/","publishdate":"2017-04-04T00:00:00+02:00","relpermalink":"/post/lief-release/","section":"post","summary":"We are open-sourcing LIEF, a library to parse and manipulate ELF, PE and Mach-O binary formats. This blog post explains the purpose of this project and some parts of its architecture.","tags":["lief"],"title":"Open-sourcing LIEF","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" Slides   Video  ","date":1478736e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1478736e3,"objectID":"1a0735ba90301927102613b40ff00d89","permalink":"/publication/triton-vm-protection/","publishdate":"2016-11-10T00:00:00Z","relpermalink":"/publication/triton-vm-protection/","section":"publication","summary":"The first part of the talk is going to be an introduction to the Triton framework to expose its components and to explain how they work together. Then, the second part will include demonstrations on how it's possible to reverse virtual machine based protections using taint analysis, symbolic execution, SMT simplifications and LLVM-IR optimizations. ","tags":null,"title":"How Triton can help to reverse virtual machine based software protections","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"The purpose of this project is to provide a cross platform library to parse, modify and abstract ELF, PE and MachO formats.\nIt turns out that many projects need to parse executable formats and they usually re-implement their own parser. Moreover these parsers are usually bound to one language.\nLIEF attempts to fill this void.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"27b392443c4beb74582d91fdf0b881e8","permalink":"/project/lief/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/lief/","section":"project","summary":"LIEF is a Library to Instrument Executable Formats","tags":["lief","parser"],"title":"LIEF","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"466702894b9681de603c2d20894ce92c","permalink":"/projects-images/qlist/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/projects-images/qlist/","section":"projects-images","summary":"QList object layout from Qt 5.11.2","tags":["Qt","diagram"],"title":"QList","type":"projects-images"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"079a1531ec30efe31f620e573d057fa0","permalink":"/projects-images/qstring/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/projects-images/qstring/","section":"projects-images","summary":"QString object layout from Qt 5.11.2","tags":["Qt","diagram"],"title":"QString","type":"projects-images"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" ","date":1460073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1460073600,"objectID":"f5b338a9867ab7600598bc82969348e5","permalink":"/publication/dynamic-binary-analysis-and-obfuscation/","publishdate":"2016-04-08T00:00:00Z","relpermalink":"/publication/dynamic-binary-analysis-and-obfuscation/","section":"publication","summary":"At this presentation we will talk about how a DBA (Dynamic Binary Analysis) may help a reverse engineer to reverse obfuscated code. We will first introduce some basic obfuscation techniques and then expose how it's possible to break some stuffs (using our open-source DBA framework - Triton) like detect opaque predicates, reconstruct CFG, find the original algorithm, isolate sensible data and many more... Then, we will conclude with a demo and few words about our future work. ","tags":null,"title":"Dynamic Binary Analysis and Obfuscated Codes","type":"publication"},{"authors":["Romain Thomas"],"categories":null,"content":"Introduction The crypto 300 challenge was about RSA with a special generation of the prime numbers $p$ and $q$. We were given a mail mail.msg which has been encrypted with RSA and whose the public key is in the hitbctf.crt certificate.\nRSA\u0026rsquo;s Parameters Construction The modulus $N$ is built by choosing randomly a first prime number $p$, the second prime number $q$ is constructed in the following way:\n$$\\alpha \\cdot (p - 1) \\equiv 1 \\pmod{e}$$\n$$q = (p\\alpha \\bmod e) + k\\cdot e$$\n$k$ is a positive integer such as $q$ is a prime number and $e$ is the public exponent which is also a random prime number.\nThe following code is the implementation in Python:\ndef gen_rsa_parameters(): r = os.urandom(63) e = int(r.encode(\u0026#39;hex\u0026#39;), 16) e = next_prime(e) r = os.urandom(64) p = int(r.encode(\u0026#39;hex\u0026#39;), 16) p = next_prime(p) q = (p*modinv(p-1, e)%e) while not is_prime(q): q += e N = p*q phi = (p-1)*(q-1) d = modinv(e,phi) return N,e,d,p,q Theoretical attack Let\u0026rsquo;s $N^{\\prime} = N \\bmod{e}$. So we have\n\\begin{eqnarray} N^{\\prime} \u0026amp; \\equiv \u0026amp; p \\cdot q \\pmod{e} \\\\\\\n\u0026amp; \\equiv \u0026amp; p \\cdot ((p\\alpha \\bmod e) + k\\cdot e) \\pmod{e} \\\\\\\n\u0026amp; \\equiv \u0026amp; p^2\\alpha \\pmod{e} \\\\\\\n\\end{eqnarray}\nWe have $\\alpha$ in the equation so we can introduce $p - 1$ to remove $\\alpha$\n\\begin{eqnarray} N^{\\prime} \u0026amp; \\equiv \u0026amp; (p - 1 + 1)^2\\alpha \\pmod{e} \\\\\\\n\u0026amp; \\equiv \u0026amp; (p - 1)^2\\alpha + 2(p - 1)\\alpha + \\alpha \\pmod{e} \\\\\\\n\u0026amp; \\equiv \u0026amp; (p - 1) + 2 + \\alpha \\pmod{e} \\\\\\\n(p - 1)N^{\\prime} \u0026amp; \\equiv \u0026amp; (p - 1)^2 + 2(p - 1) + 1 \\pmod{e} \\end{eqnarray}\n$$\\boxed{(p - 1)^2 - (N^{\\prime} - 2)(p - 1) + 1 \\equiv 0 \\pmod{e}}$$\nNow we have a quadratic equation which only depends on $p$.\nLet\u0026rsquo;s $X = p - 1$ and suppose that $N^{\\prime} - 2$ is even and $N^{\\prime} - 2 = 2b$.\n\\begin{eqnarray} X^2 - 2bX + 1 \u0026amp; \\equiv \u0026amp; 0 \u0026amp; \\pmod{e} \\\\\\\n(X - b)^2 - b^2 + 1 \u0026amp; \\equiv \u0026amp; 0 \u0026amp; \\pmod{e}\\\\\\\n(X - b)^2 \u0026amp; \\equiv \u0026amp; b^2 - 1 \u0026amp; \\pmod{e} \\end{eqnarray}\nby using quadratic residue we can find a solution. We can also use SAGE and the sqrt() function:\nNp = N % e b = (Np - 2) / 2 p = Mod(pow(b, 2) - 1, e).sqrt() + b + 1 At this point, we find $p \\bmod{e}$ but not $p$ !\nI tried to find $p$ by adding some $e$ but the distance between $p$ and $p \\bmod{e}$ is huge. So I had to find another way.\nBy knowing $p \\bmod{e}$ we can compute $\\alpha$. Remember $$\\alpha \\cdot (p - 1) \\equiv 1 \\pmod{e}$$ and by having $\\alpha$ and $p \\bmod{e}$ we can brute force $q$ by adding $e$ until $(p\\alpha \\bmod e) + k\\cdot e$ is prime and it divide $N$.\nWe did the assumption that $N^{\\prime} - 2$ has to be even (so $N^{\\prime}$ must be even) and in the certificate $N^{\\prime}$ is even so everything is right.\nPratical Attack First we have to extract the modulus $N$ and the public key $e$ from the certificate:\n$ openssl x509 -in hitbctf.crt -text -noout Certificate: Data: Version: 1 (0x0) Serial Number: 18379438180976429416 (0xff10e1a5ac5a0968) Signature Algorithm: sha1WithRSAEncryption Issuer: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF Validity Not Before: May 24 09:58:26 2015 GMT Not After : May 23 09:58:26 2016 GMT Subject: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:e6:eb:89:c1:8d:49:c9:a2:02:2b:e0:b4:65:14: 6e:0f:90:45:1e:a3:4c:6b:60:56:00:4e:bd:15:59: 55:b1:35:96:c2:d6:83:ad:2f:23:6b:0b:2c:0e:0b: 88:83:b5:d6:cb:8a:0b:4f:f9:b7:eb:64:8c:95:2b: 6b:ef:5a:6f:04:f5:64:17:f5:1c:a9:14:d9:ea:73: e7:dd:c5:f2:0d:ce:c3:9c:e8:4b:72:2a:0c:f3:d8: 5e:80:ce:78:64:63:e1:44:f6:1d:b5:9c:cf:45:ff: 0e:d3:7f:d0:ce:bd:37:a5:8d:8a:4b:08:33:9e:a3: 2c:bc:ab:61:64:03:fd:2c:c5 Exponent: 69:60:2d:93:8a:81:5f:14:cf:9f:b8:36:c2:e0:4d: 4d:De:82:ba:fc:8d:56:c2:6d:8c:89:ef:3c:40:69: 5d:d5:d4:ef:a7:36:36:43:15:14:95:f3:8c:bf:24: ae:94:30:92:40:79:12:00:1b:17:f5:53:33:9e:92: 70:70:49 Signature Algorithm: sha1WithRSAEncryption 17:2b:ea:be:90:ad:98:f2:2b:ff:f5:61:d3:ea:af:fb:35:3a: 67:10:91:13:db:60:55:d9:09:8b:c2:1a:cf:6b:c6:1f:f2:10: 7a:d1:7b:9d:ff:10:f2:f2:c0:a9:f5:aa:2e:09:93:40:88:92: 7d:98:ff:e1:cb:dc:db:35:8d:e0:4b:21:99:76:bf:db:04:a2: 62:a4:18:4e:fc:bb:a7:53:be:6a:a1:ef:ec:15:86:c1:f1:1e: 87:6a:e9:af:fe:d1:08:eb:de:22:28:c4:5e:be:f1:41:0a:ca: cf:cf:da:63:b1:c1:56:e8:0c:8e:56:7f:08:94:0d:2b:2a:08: N = 1621575882314321757502664197090844942567381491984167028188381926885851 995558397927547394115469298694885747314992315746872071523931715177680193273 386465775883129725436206653605910592810579794603402792446164893148622893121 957048204358672599654432857497196823273138934901636721473789115585263150131 66594183212229\ne = 21558488234539889837938770635971330903489839146766895224490179041465516 1931455822669631548838317075220811407344210520390992334648372016602816069805 30249\nWith SAGE:\nsage: Np = N % e sage: b = (Np - 2) / 2 sage: pp = int(Mod(pow(b, 2) - 1, e).sqrt()) + b + 1 sage: alpha = inverse_mod(int(X), int(e)) sage: q = (pp * alpha) % e sage: while not is_prime(q) and N % q != 0: ....: q += e sage: p = N / q sage: p 13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641 sage: q 12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069 We can now generate the private key by using rsatool:\n$ ./rsatools.py -o private.pem \\ -e 21558488234539889837938770635971330903489839146766895224490179041465516193145582266963154883831707522081140734421052039099233464837201660281606980530249 \\ -p 13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641 \\ -q 12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069 Finally, we can decrypt the message:\nopenssl smime -decrypt -in mail.msg -inkey private.pem hitb{0b21cc2025534dbd2965390d2bcef45d} The sources are available here\n","date":1446505200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1446505200,"objectID":"0e02cfdbbf0d76f6b938bbced44879ea","permalink":"/post/writeup-hitb2015-crypto300/","publishdate":"2015-11-03T00:00:00+01:00","relpermalink":"/post/writeup-hitb2015-crypto300/","section":"post","summary":"Write up","tags":["write-up","cryptography"],"title":"HITB 2015 Write-up - Crypto 300","type":"post"},{"authors":["Romain Thomas"],"categories":null,"content":"Introduction The crypto 400 challenge deals with the Even Mansour cryptosystem. To validate this challenge we have to send the flag to a server. The server checks if the answer matches the flag by encrypting the flag and the given message with a random key. If both are equal the flag is correct otherwise it fails and the encrypted message is printed.\nkey = os.urandom(32) enc_flag = encrypt(flag, key) enc = encrypt(answer, key) if enc == enc_flag: response = \u0026#34;You lucky bastard, %sis indeed the correct flag!\\n\u0026#34; % flag else: response = \u0026#34;Unfortunately that is not our flag :(\\n\u0026#34; response += \u0026#34;Your guess encrypts as\\n%s\u0026#34; % enc response += \u0026#34;whereas our flag encrypts as\\n%s\u0026#34; % enc_flag Even Mansour scheme In this Even-Masour scheme the size of a block is 16-bytes and the key \u0026mdash; on 32-bytes \u0026mdash; is split in two: $k_1$ and $k_2$ each one on 16-bytes. At first, the message $M$ is xor-ed with $k_1$ then $M \\oplus k_1$ is going through a $F$ function which will be discussed later. Finally the output is xor-ed with $k_2$.\nSo we have:\n$$C = F(M \\oplus k_1) \\oplus k_2$$\ndef EvenMansour(block, key): block = xor(block, key[:16]) block = F(block) block = xor(block, key[16:]) return block In this challenge, the weakness comes from the $F$ function.\n$F$ function The $F$ function is composed of 64-rounds that perform the step(...) transformation:\ndef F(block): for i in range(64): block = step(block) return block step uses a S-Box to transform the block in this way:\n$\\begin{cases} \\text{block}^{n+1}_0 = \\text{SBox}(\\text{block}^{n}_{10} \\oplus \\text{block}^{n}_{12} \\oplus \\text{block}^{n}_{13} \\oplus \\text{block}^{n+1}_{15}) \u0026amp; k = 0 \\\\\\\n\\text{block}^{n+1}_k = \\text{block}^{n}_{k - 1} \u0026amp; k \u0026gt; 0 \\end{cases}$\n$\\text{block}^{n}_k$ is the byte $k$ of the block at round $n$ ($0 \\leq k \u0026lt; 16$ and $0 \\leq n \u0026lt; 64$)\ndef step(block): return chr( S[ ord(block[10]) ^ ord(block[12]) ^ ord(block[13]) ^ ord(block[15]) ] ) + block[:15] By ploting $y = \\text{S-Box}(x)$ we can notice that the S-Box has a special construction:\nI thought about computing the differential characteristics which is the probability that given the input difference $\\Delta = x \\oplus y$ we get the output delta: $\\delta = S(x) \\oplus S(y)$. We will call this probability $P(\\Delta | \\delta)$ and with following function, we can compute this probability:\ndef P(dx ,dy): count = 0; for x in range(len(SBox)): dY = SBox[x] ^ SBox[x ^ dx] if dY == dy: count += 1; return float(count) / float(256) For all $\\Delta$ and $\\delta$, we notice that this probability is either 0 or 1. Consequently if we know $\\delta$ we are sure to find $\\Delta$. This will be useful for the differential attack.\nDifferential Attack To find the flag, we will perform a differential attack. We have a message $M_1$ that we know and we have an unknown second message $M_2$ that is the flag. We also know $C_1$ and $C_2$ such as:\n$$\\begin{eqnarray} C_1 \u0026amp; = \u0026amp; F(M_1 \\oplus k_1) \\oplus k_2 \\\\\\\nC_2 \u0026amp; = \u0026amp; F(M_2 \\oplus k_1) \\oplus k_2 \\end{eqnarray}$$\nBy xor-ing $C_1$ and $C_2$ we can get $\\Delta W = W_1 \\oplus W_2 = C_1 \\oplus C_2$. If somehow we can resolve $\\Delta V$:\n$$\\begin{eqnarray} \\Delta V \u0026amp; = \u0026amp; V_1 \\oplus V_2 \\\\\\\n\u0026amp; = \u0026amp; M_1 \\oplus k_1 \\oplus M_2 \\oplus k_1\\\\\\\n\u0026amp; = \u0026amp; M_1 \\oplus M_2. \\end{eqnarray}$$\nWe can extract $M_2$ with:\n$$M_2 = \\Delta V \\oplus M_1$$\nRecovering $\\Delta V$ Now, let\u0026rsquo;s see how to resolve $\\Delta V$ from $\\Delta W$.\nFrom the step function, we know that $\\text{block}^{n+1}_k = \\text{block}^{n}_{k - 1}$ therefore:\n$$\\Delta W^{n-1}_k = \\Delta W^{n}_{k + 1} \\forall k \u0026lt; 15$$\nWe know also $\\Delta W^{n-1}_{0,1,2 \\ldots 14}$ but not $\\Delta W^{n-1}_{15}$\nTo find $\\Delta W^{n-1}_{15}$ we will use the fact that $P(\\Delta X | \\Delta W^{n-1}_{15}) = 1$ for a given $\\Delta X$. Concretely, I built a table diffTable which maps $\\delta$ to $\\Delta$.\n$\\begin{eqnarray} \\text{diffTable}(\\Delta W^{n}_{0}) \u0026amp; = \u0026amp; \\Delta W^{n-1}_{10} \\oplus \\Delta W^{n-1}_{12} \\oplus \\Delta W^{n-1}_{13} \\oplus \\Delta W^{n-1}_{15} \\\\\\\n\u0026amp; = \u0026amp; \\Delta W^{n}_{11} \\oplus \\Delta W^{n}_{13} \\oplus \\Delta W^{n}_{14} \\oplus \\Delta W^{n-1}_{15}\\\\\\\n\\Delta W^{n-1}_{15} \u0026amp; = \u0026amp; \\text{diffTable}(\\Delta W^{n}_{0}) \\oplus \\Delta W^{n}_{11} \\oplus \\Delta W^{n}_{13} \\oplus \\Delta W^{n}_{14} \\end{eqnarray}$\nWhich enables to recover $\\Delta W^{n - 1}$ from $\\Delta W^{n}$. Then, with recursion we can compute $\\Delta W^{0} = \\Delta V$\nImplementation The following script is the implementation of the attack:\n#!/usr/bin/python2.7 # -*- coding: utf-8 -*- import os S = [ 0xa5,0xc6,0x62,0x01,0x49,0x2a,0x8e,0xed,0x1f,0x7c,0xd8,0xbb,0xf3,0x90,0x34,0x57, 0xb3,0xd0,0x74,0x17,0x5f,0x3c,0x98,0xfb,0x09,0x6a,0xce,0xad,0xe5,0x86,0x22,0x41, 0x89,0xea,0x4e,0x2d,0x65,0x06,0xa2,0xc1,0x33,0x50,0xf4,0x97,0xdf,0xbc,0x18,0x7b, 0x9f,0xfc,0x58,0x3b,0x73,0x10,0xb4,0xd7,0x25,0x46,0xe2,0x81,0xc9,0xaa,0x0e,0x6d, 0xfd,0x9e,0x3a,0x59,0x11,0x72,0xd6,0xb5,0x47,0x24,0x80,0xe3,0xab,0xc8,0x6c,0x0f, 0xeb,0x88,0x2c,0x4f,0x07,0x64,0xc0,0xa3,0x51,0x32,0x96,0xf5,0xbd,0xde,0x7a,0x19, 0xd1,0xb2,0x16,0x75,0x3d,0x5e,0xfa,0x99,0x6b,0x08,0xac,0xcf,0x87,0xe4,0x40,0x23, 0xc7,0xa4,0x00,0x63,0x2b,0x48,0xec,0x8f,0x7d,0x1e,0xba,0xd9,0x91,0xf2,0x56,0x35, 0x14,0x77,0xd3,0xb0,0xf8,0x9b,0x3f,0x5c,0xae,0xcd,0x69,0x0a,0x42,0x21,0x85,0xe6, 0x02,0x61,0xc5,0xa6,0xee,0x8d,0x29,0x4a,0xb8,0xdb,0x7f,0x1c,0x54,0x37,0x93,0xf0, 0x38,0x5b,0xff,0x9c,0xd4,0xb7,0x13,0x70,0x82,0xe1,0x45,0x26,0x6e,0x0d,0xa9,0xca, 0x2e,0x4d,0xe9,0x8a,0xc2,0xa1,0x05,0x66,0x94,0xf7,0x53,0x30,0x78,0x1b,0xbf,0xdc, 0x4c,0x2f,0x8b,0xe8,0xa0,0xc3,0x67,0x04,0xf6,0x95,0x31,0x52,0x1a,0x79,0xdd,0xbe, 0x5a,0x39,0x9d,0xfe,0xb6,0xd5,0x71,0x12,0xe0,0x83,0x27,0x44,0x0c,0x6f,0xcb,0xa8, 0x60,0x03,0xa7,0xc4,0x8c,0xef,0x4b,0x28,0xda,0xb9,0x1d,0x7e,0x36,0x55,0xf1,0x92, 0x76,0x15,0xb1,0xd2,0x9a,0xf9,0x5d,0x3e,0xcc,0xaf,0x0b,0x68,0x20,0x43,0xe7,0x84 ] def xor(block1, block2): return \u0026#34;\u0026#34;.join( chr(ord(a) ^ ord(b)) for (a,b) in zip(block1, block2)) def step(block): return chr(S[ord(block[10]) ^ ord(block[12]) ^ ord(block[13]) ^ ord(block[15])]) + block[:15] def F(block): for i in xrange(64): block = step(block) return block def EvenMansour(block, key): block = xor(block, key[:16]) block = F(block) block = xor(block, key[16:]) return block def encrypt(data, key): data, num_blocks = pad(data) res = \u0026#34;\u0026#34; for i in xrange(num_blocks): block = EvenMansour(data[16*i:16*i+16], key) res += block return res def pad(data): while True: data += \u0026#39;\\x00\u0026#39; if len(data) % 16 == 0: return data, len(data) / 16 # # Table T[a] = b such as # S[x] ^ S[y] = a and b = x ^ y # def DiffTable(S): table = [0 for i in range(len(S))] for delta in range(len(S)): for x in range(len(S)): dY = S[x] ^ S[x ^ delta] table[dY] = delta return table def main(): key = os.urandom(32) M1 = \u0026#34;hitb{0123456789abcdef}\u0026#34; M2 = \u0026#34;aaaaaaaaaaaaaaaaaaaaaa\u0026#34; C1 = encrypt(M1, key) C2 = encrypt(M2, key) numberOfBlocks = len(C2) / 16 diffTable = DiffTable(S) clearText = \u0026#34;\u0026#34; for block in range(numberOfBlocks): dW = xor(C1,C2)[16 * block : 16 * (block + 1)] for i in range(64): dWtemp = [dW[i + 1] for i in range(15)] delta = diffTable[ord(dW[0])] dW15 = chr(ord(dW[11]) ^ ord(dW[13]) ^ ord(dW[14]) ^ delta) dWtemp.append(dW15) dW = \u0026#34;\u0026#34;.join(dWtemp) M = xor(dW, M2[16 * block : 16 * (block + 1)]) clearText += M print clearText if __name__ == \u0026#39;__main__\u0026#39;: main() Conclusion In fact by noticing that\n$$F(x \\oplus y) = F(x) \\oplus F(y) \\oplus C^{te}$$\nfor b in xrange(10): u = os.urandom(16); v = os.urandom(16); d = xor(F(xor(u,v)), xor(F(u), F(v))) print d.encode(\u0026#34;hex\u0026#34;) We have:\n\\begin{eqnarray} F(M_1 \\oplus k_1) \\oplus F(M_2 \\oplus k_1) \u0026amp; = \u0026amp; F(M_1) \\oplus F(M_2)\\\nM_2 \u0026amp; = \u0026amp; F^{-1}(F(M_1) \\oplus C_1 \\oplus C_2) \\end{eqnarray}\nWhich is far more easier to resolve.\nThanks to jb^ who help me and who find the previous technique.\nSources are available here\n","date":1446505200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1446505200,"objectID":"5eacf2427d5b25802dcc121d90447841","permalink":"/post/writeup-hitb2015-crypto400/","publishdate":"2015-11-03T00:00:00+01:00","relpermalink":"/post/writeup-hitb2015-crypto400/","section":"post","summary":"Write up","tags":["write-up","cryptography"],"title":"HITB 2015 Write-up - Crypto 400","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":"","date":1444600800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1444600800,"objectID":"a10174ef78fc9ed80bf0a1596641ccb9","permalink":"/post/triton-code-coverage/","publishdate":"2015-10-12T00:00:00+02:00","relpermalink":"/post/triton-code-coverage/","section":"post","summary":"This blog post introduces code coverage with Triton","tags":[""],"title":"Code coverage using a dynamic symbolic execution","type":"post"},{"authors":["Jonathan Salwan","Romain Thomas"],"categories":null,"content":" ","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"e47dace0552b838319d6e65e53b32139","permalink":"/publication/triton/","publishdate":"2015-09-01T00:00:00Z","relpermalink":"/publication/triton/","section":"publication","summary":"Binary obfuscation is used to protect software's intellectual property. There exist different kinds of obfucation but roughly, it transforms a binary structure into another binary structure by preserving the same semantic. The aim of obfuscation is to ensure that the original information is 'drown' in useless information that will make reverse engineering harder. In this article we will show how we can analyse an ofbuscated program and break some obfuscations using the Triton framework","tags":null,"title":"How Triton may help to analyse obfuscated binaries","type":"publication"}]