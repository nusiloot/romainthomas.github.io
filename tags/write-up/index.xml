<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>write-up | Romain Thomas</title><link>/tags/write-up/</link><atom:link href="/tags/write-up/index.xml" rel="self" type="application/rss+xml"/><description>write-up</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Published with Academic Website Builder - Icons made by Freepik</copyright><lastBuildDate>Sun, 27 Sep 2020 00:00:00 +0000</lastBuildDate><image><url>/images/icon_hu2654a0fcc87c65a864822ac27b001d3b_698_512x512_fill_lanczos_center_2.png</url><title>write-up</title><link>/tags/write-up/</link></image><item><title>r2-pay: whitebox (part 2)</title><link>/post/20-09-r2con-obfuscated-whitebox-part2/</link><pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate><guid>/post/20-09-r2con-obfuscated-whitebox-part2/</guid><description>&lt;style>
.green {
color:green;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.blue {
color: blue;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.orange {
color: #FF6347;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.red {
color: #df2b04;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-comment {
color: #df2b04;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-keyword {
color: #A90D91;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-literal {
color: #1C01CE;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-preproc {
color: #633820;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-strings {
color: #C41A16;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.yellow {
color: #CC7000;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
#
&lt;/style>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In the
&lt;a href="/post/20-09-r2con-obfuscated-whitebox-part1/">first part&lt;/a> of this write-up, we described the
anti-frida, anti-debug and anti-root techniques used in the application and how to remove most of them.&lt;/p>
&lt;p>This second part digs into the JNI function &lt;code>gXftm3iswpkVgBNDUp&lt;/code> and the underlying whitebox implementation.&lt;/p>
&lt;h2 id="library-shimming">Library Shimming&lt;/h2>
&lt;p>The inputs of the function &lt;code>gXftm3iswpkVgBNDUp&lt;/code> are provided by the GUI widgets and the function
is triggered when we press the &lt;em>Generate R2Coin&lt;/em> button.
Nevertheless, the behavior of &lt;code>gXftm3iswpkVgBNDUp&lt;/code> does not rely on UI features nor
the application&amp;rsquo;s context&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>To take a closer look at the logic of &lt;code>gXftm3iswpkVgBNDUp&lt;/code>, it would be pretty useful to be able to feed
the function&amp;rsquo;s inputs with our &lt;strong>own standalone binary&lt;/strong>. Basically, we would like to achieve this kind
of interface:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> argv) {
&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> dlopen(&lt;span style="color:#e6db74">&amp;#34;libnative-lib.so&amp;#34;&lt;/span>, RTLD_NOW);
...
jbyteArray out &lt;span style="color:#f92672">=&lt;/span> gXftm3iswpkVgBNDUp(env, ...);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This technique is not new and has been already described in a blog post by
&lt;a href="https://twitter.com/caleb_fenton" target="_blank" rel="noopener">Caleb Fenton&lt;/a>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. The idea is to get
the &lt;code>JNIEnv* env&lt;/code> variable with &lt;code>JNI_CreateJavaVM&lt;/code> which is exported by the Android runtime: &lt;code>libart.so&lt;/code>.&lt;/p>
&lt;p>Once we have this variable, we can call the &lt;code>gXftm3iswpkVgBNDUp&lt;/code> function as well as manipulating the JNI buffers:&lt;/p>
&lt;ul>
&lt;li>&lt;code>env-&amp;gt;NewByteArray()&lt;/code>&lt;/li>
&lt;li>&lt;code>env-&amp;gt;GetArrayLength()&lt;/code>&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="shim_mechanism.png" alt="Shimming of whitebox library">&lt;/p>
&lt;p>Long story short, we can instantiate the Android runtime with the following piece of code:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> argv) {
JavaVMOption opt[&lt;span style="color:#ae81ff">2&lt;/span>];
opt[&lt;span style="color:#ae81ff">0&lt;/span>].optionString &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-Djava.class.path=/data/local/tmp/re.pwnme.1.0.apk&amp;#34;&lt;/span>;
opt[&lt;span style="color:#ae81ff">1&lt;/span>].optionString &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-Djava.library.path=/data/local/tmp&amp;#34;&lt;/span>;
JavaVMInitArgs args;
args.version &lt;span style="color:#f92672">=&lt;/span> JNI_VERSION_1_6;
args.options &lt;span style="color:#f92672">=&lt;/span> opt;
args.nOptions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
args.ignoreUnrecognized &lt;span style="color:#f92672">=&lt;/span> JNI_FALSE;
&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> handler &lt;span style="color:#f92672">=&lt;/span> dlopen(&lt;span style="color:#e6db74">&amp;#34;/system/lib64/libart.so&amp;#34;&lt;/span>, RTLD_NOW);
&lt;span style="color:#66d9ef">auto&lt;/span> JNI_CreateJavaVM_f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">decltype&lt;/span>(JNI_CreateJavaVM)&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(dlsym(handler, &lt;span style="color:#e6db74">&amp;#34;JNI_CreateJavaVM&amp;#34;&lt;/span>));
JNI_CreateJavaVM_f(&lt;span style="color:#f92672">&amp;amp;&lt;/span>jvm, &lt;span style="color:#f92672">&amp;amp;&lt;/span>env, &lt;span style="color:#f92672">&amp;amp;&lt;/span>args);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we can resolve the &lt;code>gXftm3iswpkVgBNDUp&lt;/code> function with the base address of &lt;code>libnative-lib.so&lt;/code>
and its offset &lt;code>0x9B41C&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> hdl &lt;span style="color:#f92672">=&lt;/span> dlopen(&lt;span style="color:#e6db74">&amp;#34;libnative-lib.so&amp;#34;&lt;/span>, RTLD_NOW);
uintptr_t base_address &lt;span style="color:#f92672">=&lt;/span> get_base_address(&lt;span style="color:#e6db74">&amp;#34;libnative-lib.so&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">using&lt;/span> gXftm3iswpkVgBNDUp_t &lt;span style="color:#f92672">=&lt;/span> jbyteArray(&lt;span style="color:#f92672">*&lt;/span>)(JNIEnv&lt;span style="color:#f92672">*&lt;/span>, jobject, jbyteArray, jbyte);
gXftm3iswpkVgBNDUp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>gXftm3iswpkVgBNDUp_t&lt;span style="color:#f92672">&amp;gt;&lt;/span>(base_address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x9B41C&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we can run the function with our own inputs:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">std&lt;span style="color:#f92672">::&lt;/span>string pin_amount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0000123400004567&amp;#34;&lt;/span>;
jbyteArray array &lt;span style="color:#f92672">=&lt;/span> convert_to_jbyteArray(pin_amount, ptr);
jbyteArray jencrypted_buffer &lt;span style="color:#f92672">=&lt;/span> gXftm3iswpkVgBNDUp(env, &lt;span style="color:#66d9ef">nullptr&lt;/span>, array, &lt;span style="color:#ae81ff">0xF0&lt;/span>);
&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> encrypted_buffer &lt;span style="color:#f92672">=&lt;/span> from_jbytes(jencrypted_buffer);
std&lt;span style="color:#f92672">::&lt;/span>string hex_str &lt;span style="color:#f92672">=&lt;/span> to_hex(encrypted_buffer);
LOG_INFO(&lt;span style="color:#e6db74">&amp;#34;{} --&amp;gt; {}&amp;#34;&lt;/span>, pin_amount, ref_str);
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="alert alert-note">
&lt;div>
The whole implementation is available &lt;a href="https://github.com/romainthomas/r2pay/blob/master/shim-whitebox">here &lt;i class="fab fa-github">&lt;/i>&lt;/a>.
&lt;/div>
&lt;/div>
&lt;h2 id="function-tracing">Function Tracing&lt;/h2>
&lt;p>Now that we are able to run the &lt;code>gXftm3iswpkVgBNDUp&lt;/code> function without the GUI layer, we can easily
create an interface with
&lt;a href="https://qbdi.quarkslab.com" target="_blank" rel="noopener">QBDI&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">VM vm;
vm.addInstrumentedModule(&lt;span style="color:#e6db74">&amp;#34;libnative-lib.so&amp;#34;&lt;/span>);
...
jbyteArray array &lt;span style="color:#f92672">=&lt;/span> to_jarray(pin_amount, ptr);
jbyteArray qbdi_encrypted_buffer;
vm.call(
&lt;span style="color:#75715e">/* ret */&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uintptr_t&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>qbdi_encrypted_buffer),
&lt;span style="color:#75715e">/* target */&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>uintptr_t&lt;span style="color:#f92672">&amp;gt;&lt;/span>(gXftm3iswpkVgBNDUp),
&lt;span style="color:#75715e">/* params */&lt;/span> {
&lt;span style="color:#75715e">/* p_0: JNIEnv* */&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>rword&lt;span style="color:#f92672">&amp;gt;&lt;/span>(env),
&lt;span style="color:#75715e">/* p_1: jobject thiz */&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>rword&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">nullptr&lt;/span>),
&lt;span style="color:#75715e">/* p_2: inbuffer */&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>rword&lt;span style="color:#f92672">&amp;gt;&lt;/span>(array),
&lt;span style="color:#ae81ff">0xF0&lt;/span>
}
);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The execution in QBDI &lt;strong>without user&amp;rsquo;s callbacks&lt;/strong> takes about &lt;strong>3min 30s&lt;/strong> which is quite huge compared to
the &lt;strong>real execution&lt;/strong> that takes about &lt;strong>853ms&lt;/strong>:&lt;/p>
&lt;p>&lt;img src="benchmark.svg" alt="Performances with different configurations">&lt;/p>
&lt;p>This overhead is mostly due to the function &lt;code>0x1038f0&lt;/code> that is executed ~20 000 times. After a quick
analysis, it turns out that this function is not relevant to instrument to break the whitebox.
We can force its &lt;em>real&lt;/em> execution
(i.e. outside QBDI) &lt;strong>by removing the function&amp;rsquo;s address from the instrumented range&lt;/strong>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> uintptr_t HEAVY_FUNCTION &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x1038f0&lt;/span>;
vm.removeInstrumentedRange(
base_address &lt;span style="color:#f92672">+&lt;/span> HEAVY_FUNCTION,
base_address &lt;span style="color:#f92672">+&lt;/span> HEAVY_FUNCTION &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This small adjustment &lt;strong>drops the execution to 3'30sec&lt;/strong>.&lt;/p>
&lt;hr>
&lt;p>Some cryptographic algorithms can be fingerprinted either with predefined constants or with their memory accesses.
According to the Quarkslab&amp;rsquo;s blog post:
&lt;a href="https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html" target="_blank" rel="noopener">Differential Fault Analysis on White-box AES Implementations&lt;/a>,
the whitebox lookup tables are likely to be stored in the &lt;code>.data, .rodata, ...&lt;/code> sections.&lt;/p>
&lt;p>By looking at the sizes of these sections, only the &lt;code>.data&lt;/code> section seems to have an appropriate size.
We can generate a memory trace on this section to see if we can outline some patterns.
It can be made with the following piece of code:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">vm.recordMemoryAccess(MEMORY_READ_WRITE);
vm.addMemRangeCB(
&lt;span style="color:#75715e">/* .data start address */&lt;/span> base_address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x127000&lt;/span>,
&lt;span style="color:#75715e">/* .data end address */&lt;/span> base_address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x127000&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x8e000&lt;/span>,
&lt;span style="color:#75715e">/* Record both: reads and writes */&lt;/span> MEMORY_READ_WRITE,
&lt;span style="color:#75715e">/* Memory callback */&lt;/span>
[] (VM&lt;span style="color:#f92672">*&lt;/span> vm, GPRState&lt;span style="color:#f92672">*&lt;/span>, FPRState&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> data) {
&lt;span style="color:#66d9ef">auto&lt;/span> ctx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>qbdi_ctx&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(data);
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e"> * &amp;#39;for&amp;#39; loop since on AArch64 we can have multiple reads / writes
&lt;/span>&lt;span style="color:#75715e"> * at once. (e.g. stp x0, x1, [sp, #128])
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> MemoryAccess&lt;span style="color:#f92672">&amp;amp;&lt;/span> mem_access : vm&lt;span style="color:#f92672">-&amp;gt;&lt;/span>getInstMemoryAccess()) {
ctx&lt;span style="color:#f92672">-&amp;gt;&lt;/span>trace&lt;span style="color:#f92672">-&amp;gt;&lt;/span>push_back({
mem_access.instAddress &lt;span style="color:#f92672">-&lt;/span> base_address,
mem_access.accessAddress &lt;span style="color:#f92672">-&lt;/span> base_address,
mem_access.size,
});
}
&lt;span style="color:#66d9ef">return&lt;/span> VMAction&lt;span style="color:#f92672">::&lt;/span>CONTINUE;
}, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ctx);
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="alert alert-note">
&lt;div>
Generating the memory trace takes about 11sec which is acceptable.
&lt;/div>
&lt;/div>
&lt;p>It leads to the following graph in which we can notice a characteristic pattern at the end of the trace:&lt;/p>
&lt;p>&lt;img src="memory_trace.png" alt="Memory trace generated with QBDI">&lt;/p>
&lt;h2 id="fault-injection">Fault Injection&lt;/h2>
&lt;p>The pattern at the end of the trace is quite characteristic of AES-128 where we can identify 10 rounds.
&lt;img src="rounds.png" alt="AES rounds">&lt;/p>
&lt;p>We now have all the necessary information to make a &lt;em>fault injection attack&lt;/em>:&lt;/p>
&lt;ol>
&lt;li>We can identify the 9th round&lt;/li>
&lt;li>We can &lt;strong>accurately&lt;/strong> fault the &lt;code>.data&lt;/code> section thanks to the memory trace&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="injection.png" alt="Fault injection in the 9th round">&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The memory trace is available in the &lt;a href="https://github.com/romainthomas/r2pay/blob/master/assets/mem_trace.json">&lt;i class="fab fa-github">&lt;/i> mem_trace.json&lt;/a> file of the repository.
&lt;/div>
&lt;/div>
&lt;p>To efficiently make
the injection, we can first reduce the memory addresses to only keep those that are used in the last 2 rounds:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">trace_file &lt;span style="color:#f92672">=&lt;/span> CWD &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;..&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;assets&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mem_trace.json&amp;#34;&lt;/span>
trace &lt;span style="color:#f92672">=&lt;/span> json&lt;span style="color:#f92672">.&lt;/span>loads(trace_file&lt;span style="color:#f92672">.&lt;/span>read_bytes())[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;span style="color:#75715e"># Keep the entries that are involved in the last 2-rounds (empirical number)&lt;/span>
nice_trace &lt;span style="color:#f92672">=&lt;/span> trace[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1000&lt;/span>:]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we can use our shim mechanism to inject the faults in the &lt;code>.data&lt;/code> section with the addresses previously selected.
Moreover, we can reduce the set of &lt;code>.data&lt;/code> addresses with the faults that introduce exactly &lt;strong>4 differences&lt;/strong> in the ciphertext:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">// Make sure the .data section is writable
&lt;/span>&lt;span style="color:#75715e">&lt;/span>mprotect(
&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(base_address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#75715e">/* .data */&lt;/span> &lt;span style="color:#ae81ff">0x127000&lt;/span>),
&lt;span style="color:#ae81ff">0x8e000&lt;/span>,
PROT_READ &lt;span style="color:#f92672">|&lt;/span> PROT_WRITE
);
&lt;span style="color:#66d9ef">for&lt;/span> (uintptr_t fault_addr : selected_addresses) {
&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> target_byte &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(base_address &lt;span style="color:#f92672">+&lt;/span> fault_addr);
&lt;span style="color:#66d9ef">uint8_t&lt;/span> backup &lt;span style="color:#f92672">=&lt;/span> target_byte;
&lt;span style="color:#75715e">// Fault 1 byte:
&lt;/span>&lt;span style="color:#75715e">&lt;/span> target_byte &lt;span style="color:#f92672">^=&lt;/span> &lt;span style="color:#ae81ff">0x33&lt;/span>;
&lt;span style="color:#75715e">// Run the whitebox with the faulty byte
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> encrypted &lt;span style="color:#f92672">=&lt;/span> encrypt(msg);
&lt;span style="color:#75715e">// Restore the original byte
&lt;/span>&lt;span style="color:#75715e">&lt;/span> target_byte &lt;span style="color:#f92672">=&lt;/span> backup;
&lt;span style="color:#75715e">// Compute the number of errors
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, with the subset of the addresses that affect exactly 4 bytes, we can generate several faults for a given
address:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">for&lt;/span> (uintptr_t nice_fault_addr : four_bytes_fault_addresses) {
&lt;span style="color:#66d9ef">for&lt;/span> (size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">uint8_t&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> output &lt;span style="color:#f92672">=&lt;/span> inject_fault(addr, PIN_AMOUNT, i);
&lt;span style="color:#66d9ef">const&lt;/span> size_t nb_errors &lt;span style="color:#f92672">=&lt;/span> get_error(genuine_value, output);
&lt;span style="color:#66d9ef">if&lt;/span> (nb_errors &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span> and unique.insert(output).second) {
&lt;span style="color:#75715e">// Record the entry ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The aforementioned code gives an idea about how to generate the faults. One can find the whole implementation in
this file:
&lt;a href="https://github.com/romainthomas/r2pay/blob/master/shim-whitebox/src/main.cpp#L343-L365" target="_blank" rel="noopener">shim-whitebox/src/main.cpp&lt;/a> that produces
this set of files
&lt;a href="https://github.com/romainthomas/r2pay/blob/master/assets/wb-traces" target="_blank" rel="noopener">assets/wb-traces&lt;/a>.&lt;/p>
&lt;h2 id="key-extraction">Key Extraction&lt;/h2>
&lt;p>Thanks to the
&lt;a href="https://github.com/SideChannelMarvels" target="_blank" rel="noopener">&lt;i class="fab fa-github">&lt;/i> Side-Channel Marvels&lt;/a> project,
we can use
&lt;a href="https://github.com/SideChannelMarvels/JeanGrey" target="_blank" rel="noopener">JeanGrey&lt;/a> &amp;mdash; developed by Philippe Teuwen &amp;mdash; to recover the whitebox&amp;rsquo;s key from the faulty traces:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> pathlib
&lt;span style="color:#f92672">import&lt;/span> phoenixAES
CWD &lt;span style="color:#f92672">=&lt;/span> pathlib&lt;span style="color:#f92672">.&lt;/span>Path(__file__)&lt;span style="color:#f92672">.&lt;/span>parent
trace_dir &lt;span style="color:#f92672">=&lt;/span> CWD &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;..&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;assets&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;wb-traces&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> trace_dir&lt;span style="color:#f92672">.&lt;/span>iterdir():
x &lt;span style="color:#f92672">=&lt;/span> phoenixAES&lt;span style="color:#f92672">.&lt;/span>crack_file(f)
&lt;span style="color:#66d9ef">if&lt;/span> x &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#f92672">not&lt;/span> None:
&lt;span style="color:#66d9ef">print&lt;/span>(x, f&lt;span style="color:#f92672">.&lt;/span>name)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>It provides the following results which enable to retrieve the key:&lt;/p>
&lt;pre>&lt;code class="language-console" data-lang="console">$ python wb_key_recovery.py
..8D....7F............9A....79.. injection-1a930d.trace
..8D....7F............9A....79.. injection-1a95bd.trace
....19....62....B0............8F injection-1a91b2.trace
....19....62....B0............8F injection-1a8fdf.trace
76............1E....D3....E1.... injection-1a8549.trace
......E1....A0....CD....28...... injection-1a8978.trace
....19....62....B0............8F injection-1a90ce.trace
....19....62....B0............8F injection-1a8efd.trace
r 2 p 4 y 1 s N 0 w S e c u r 3
&lt;/code>&lt;/pre>&lt;p>Finally, we can verify that &lt;strong>r2p4y1sN0wSecur3&lt;/strong> is the right key by trying to decrypt &lt;code>9497cdf1df2600e7f63778d0ae91dcbb&lt;/code>&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">from&lt;/span> Crypto.Cipher &lt;span style="color:#f92672">import&lt;/span> AES
WB_KEY &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;r2p4y1sN0wSecur3&amp;#34;&lt;/span>
cipher &lt;span style="color:#f92672">=&lt;/span> AES&lt;span style="color:#f92672">.&lt;/span>new(WB_KEY, AES&lt;span style="color:#f92672">.&lt;/span>MODE_ECB)
output &lt;span style="color:#f92672">=&lt;/span> cipher&lt;span style="color:#f92672">.&lt;/span>decrypt(bytes&lt;span style="color:#f92672">.&lt;/span>fromhex(&lt;span style="color:#e6db74">&amp;#34;9497cdf1df2600e7f63778d0ae91dcbb&amp;#34;&lt;/span>))
&lt;span style="color:#66d9ef">print&lt;/span>(output&lt;span style="color:#f92672">.&lt;/span>decode())
&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code class="language-console" data-lang="console">$ python ./aes_test.py
0000123400004567
&lt;/code>&lt;/pre>&lt;h2 id="side-note-about-the-data-section">Side note about the &lt;code>.data&lt;/code> section&lt;/h2>
&lt;p>Most of the obfuscators encode strings so that we don&amp;rsquo;t have any clue about functions' logic. The obfuscator
used in the challenge follows this rule and running the &lt;code>strings&lt;/code> utility on the library does not reveal any interesting information.&lt;/p>
&lt;p>Nevertheless, we can find a lot of &lt;code>.datadiv_decode&amp;lt;random hex&amp;gt;&lt;/code> in the ELF constructors of the library.
As explained in the previous part, they are generated by the obfuscator and aimed to decode the strings.&lt;/p>
&lt;p>Since these functions are in the &lt;strong>ELF constructors&lt;/strong>, this means that they are executed as soon as the library is loaded.
In particular, when calling &lt;code>dlopen(...)&lt;/code> these constructors are executed. It can be confirmed by
dumping the &lt;code>.data&lt;/code> section right after &lt;code>dlopen()&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">dlopen(&lt;span style="color:#e6db74">&amp;#34;libnative-lib.so&amp;#34;&lt;/span>, RTLD_NOW);
std&lt;span style="color:#f92672">::&lt;/span>ofstream ofs{fmt&lt;span style="color:#f92672">::&lt;/span>format(&lt;span style="color:#e6db74">&amp;#34;/data/local/tmp/{}&amp;#34;&lt;/span>, output)};
&lt;span style="color:#66d9ef">auto&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(base_address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x127000&lt;/span>);
ofs.write(start, &lt;span style="color:#75715e">/* sizeof(.data) */&lt;/span> &lt;span style="color:#ae81ff">0x8d49f&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we can compare the bytes distribution with
&lt;a href="https://binvis.io/" target="_blank" rel="noopener">binvis.io&lt;/a>:&lt;/p>
&lt;p>&lt;img src="data_strings.png" alt="Bytes distribution in the .data section">&lt;/p>
&lt;p>At the end of the in-memory &lt;code>.data&lt;/code> section, we can found interesting strings used to detect Frida and the
device&amp;rsquo;s root state.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Thanks again to &lt;u>Eduardo Novella&lt;/u> (
&lt;a href="https://twitter.com/enovella_" target="_blank" rel="noopener">@enovella_&lt;/a>)
and &lt;u>Gautam Arvind&lt;/u> (
&lt;a href="https://twitter.com/darvincisec" target="_blank" rel="noopener">@darvincisec&lt;/a>) for this second part of the challenge :)&lt;/p>
&lt;p>Also thanks to &lt;u>
&lt;a href="https://www.quarkslab.com" target="_blank" rel="noopener">Quarkslab&lt;/a>&lt;/u> that allowed this publication.
One can find related blog posts about whitebox attacks on the Quarkslab&amp;rsquo;s blog:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>
&lt;a href="https://blog.quarkslab.com/introduction-to-whiteboxes-and-collision-based-attacks-with-qbdi.html" target="_blank" rel="noopener">Introduction to Whiteboxes and Collision-Based Attacks With QBDI
&lt;/a> by Paul Hernault (
&lt;a href="https://twitter.com/0xAcid" target="_blank" rel="noopener">@0xAcid&lt;/a>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>
&lt;a href="https://blog.quarkslab.com/when-sidechannelmarvels-meet-lief.html" target="_blank" rel="noopener">When SideChannelMarvels meet LIEF &lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>
&lt;a href="https://blog.quarkslab.com/differential-fault-analysis-on-white-box-aes-implementations.html" target="_blank" rel="noopener">Differential Fault Analysis on White-box AES
Implementations&lt;/a> by Philippe Teuwen (
&lt;a href="https://twitter.com/doegox" target="_blank" rel="noopener">@doegox&lt;/a>).
&lt;em>I used this blog post as a reference to resolve this part of the challenge.&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="references">References&lt;/h3>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://developer.android.com/reference/android/content/Context">https://developer.android.com/reference/android/content/Context&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a href="https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/">https://calebfenton.github.io/2017/04/05/creating_java_vm_from_android_native_code/&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>QBDI will execute the function using the
&lt;a href="https://qbdi.readthedocs.io/en/stable/api_cpp.html#execution-filtering" target="_blank" rel="noopener">ExecBroker&lt;/a> mechanism.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>It is the output of the function when entering &lt;code>1234&lt;/code> in the PIN field and &lt;code>4567&lt;/code> in the amount field.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>r2-pay: anti-debug, anti-root &amp; anti-frida (part 1)</title><link>/post/20-09-r2con-obfuscated-whitebox-part1/</link><pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate><guid>/post/20-09-r2con-obfuscated-whitebox-part1/</guid><description>&lt;style>
.green {
color:green;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.blue {
color: blue;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.orange {
color: #FF6347;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.red {
color: #df2b04;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-comment {
color: #df2b04;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-keyword {
color: #A90D91;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-literal {
color: #1C01CE;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-preproc {
color: #633820;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.hl-strings {
color: #C41A16;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
.yellow {
color: #CC7000;
font-family: 'Fira Code', monospace;
font-size: 87.5%;
}
#
&lt;/style>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This series of blog posts explains one way to resolve the r2-pay challenge released during the
&lt;a href="https://rada.re/con/2020/" target="_blank" rel="noopener">r2con2020&lt;/a> conference. This first part is about the
anti-analysis tricks used to hinder reverse-engineering while the second part will be more focused on
breaking the whitebox.&lt;/p>
&lt;p>The resolution took me more than a week-end but it covers nice topics that worth it: &lt;strong>obfuscation &amp;amp; whitebox&lt;/strong>.
It was also the opportunity to practice attacks against whiteboxes
and to test
&lt;a href="https://github.com/SideChannelMarvels/JeanGrey" target="_blank" rel="noopener">SideChannelMarvels/JeanGrey&lt;/a> developed by Philippe Teuwen (aka.
&lt;a href="https://twitter.com/doegox" target="_blank" rel="noopener">@doegox&lt;/a>).&lt;/p>
&lt;p>The challenge has been resolved with the AArch64 version on a device running on Android 9 and rooted with Magisk.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
&lt;p>Here are the files used in this write-up:&lt;/p>
&lt;p>&lt;i class="fas fa-mobile-alt">&lt;/i> &lt;a href="re.pwnme.1.0.apk">re.pwnme.1.0.apk - af019d3016720592aade7bde9890110c&lt;/a>&lt;/p>
&lt;p>&lt;i class="fas fa-shield-alt">&lt;/i> &lt;a href="libnative-lib.so">libnative-lib.so (arm64-v8a version)&lt;/a>&lt;/p>
&lt;/div>
&lt;/div>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>When opening the application on a non-tempered device (or with Magisk hide enabled), we are asked to enter
a PIN and an amount that is used to generate a &lt;em>token&lt;/em>.&lt;/p>
&lt;p>To resolve the challenge, we have to find the &lt;em>master key&lt;/em> that is used to generate the token.
Few days before the CTF I was told that one of the challenges
would involve an obfuscated whitebox&amp;hellip;&lt;/p>
&lt;p>The main interface of the APK is located in the Java class &lt;code>re.pwnme.MainActivity&lt;/code> which forwards the user inputs (PIN &amp;amp; amount)
to a JNI function named &lt;code>gXftm3iswpkVgBNDUp&lt;/code>. This function takes the concatenated input $PIN\ ||\ Amount$
and returns the token as a byte array.&lt;/p>
&lt;p>The &lt;strong>static constructor&lt;/strong> of the class loads the &amp;ldquo;native-lib&amp;rdquo; library which is available for the architectures:
&lt;code>arm64-v8a&lt;/code>, &lt;code>armeabi-v7a&lt;/code>, and &lt;code>x86_64&lt;/code>. Unsurprisingly, this library is obfuscated and some symbols suggest that it has
been compiled with a fork of O-LLVM &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>&lt;img src="mainactivity_tag.png" alt="re.pwnme.MainActivity in r2pay">&lt;/p>
&lt;p>In addition, the library does not export the expected symbol &lt;code>Java_re_pwnme_MainActivity_gXftm3iswpkVgBNDUp&lt;/code> but prefers
to use the &lt;code>JNI_OnLoad&lt;/code> technique &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>. &lt;code>JNI_OnLoad()&lt;/code> is also obfuscated along with control-flow-flattening.&lt;/p>
&lt;p>The main task of the challenge is to understand the logic of the &lt;code>gXftm3iswpkVgBNDUp&lt;/code> function to figure out how the
&lt;em>token&lt;/em> is generated.&lt;/p>
&lt;h2 id="anti-root--anti-frida">Anti-Root &amp;amp; Anti-Frida&lt;/h2>
&lt;p>Along with the &lt;code>libnative-lib.so&lt;/code> library, the applications embeds another library &lt;code>libtool-checker.so&lt;/code>
whose name sounds quite familiar: it comes from the open-source project
&lt;a href="https://github.com/scottyab/rootbeer" target="_blank" rel="noopener">rootbeer&lt;/a>
which is used to detect if the device is rooted.&lt;/p>
&lt;p>Some of the root-checks are done in the MainActivity class and if the device is rooted the application raises
an exception by dividing a number with 0.&lt;/p>
&lt;p>On this point, we can disable the check by using
&lt;a href="https://frida.re/" target="_blank" rel="noopener">Frida&lt;/a> on the rootbeer&amp;rsquo;s functions involved in the detection:&lt;/p>
&lt;pre>&lt;code>// frida -U -l ./bypass-root.js --no-pause -f re.pwnme
Java.perform(function () {
var RootCheck = Java.use('\u266b.\u1d64');
RootCheck['₤'].implementation = function () {
console.log(&amp;quot;Skip root&amp;quot;);
return false;
}
RootCheck['θ'].overload().implementation = function () {
console.log(&amp;quot;Skip root&amp;quot;);
return false;
}
})
&lt;/code>&lt;/pre>&lt;p>Nevertheless, the application still crashes as soon as it starts and generates the following backtrace:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">F libc : Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095 in tid 8875 (re.pwnme), pid 8849 (re.pwnme)
F DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
F DEBUG : Build fingerprint: &amp;#39;google/taimen/taimen:9/PQ3A.190801.002/5670241:user/release-keys&amp;#39;
F DEBUG : Revision: &amp;#39;rev_10&amp;#39;
F DEBUG : ABI: &amp;#39;arm64&amp;#39;
F DEBUG : pid: 8849, tid: 8875, name: re.pwnme &amp;gt;&amp;gt;&amp;gt; com.google.android.gms &amp;lt;&amp;lt;&amp;lt;
F DEBUG : signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xfa929095
F DEBUG : x0 0000007f041f6610 x1 0000007f2565c800 x2 0000007f25600000 x3 000000000000001d
F DEBUG : x4 000000000000005c x5 0000000000000001 x6 0000000000000001 x7 0000000000000000
F DEBUG : x8 0000007f041f6610 x9 0000007f041f6600 x10 00000000fa929095 x11 00000000000035b2
F DEBUG : x12 00000000e34d79ac x13 00000000fffffff7 x14 00000000a139577d x15 0000000000000001
F DEBUG : x16 0000007fa66af220 x17 0000007fa65e3608 x18 0000000000000000 x19 0000007f041f6680
F DEBUG : x20 0000000000000000 x21 0000000000000000 x22 0000229100002291 x23 0000000000000000
F DEBUG : x24 0000007f041ff570 x25 0000007f04102000 x26 0000007fab1ad5e0 x27 0000007f0421a690
F DEBUG : x28 0000007f04209080 x29 0000007f041ff490
F DEBUG : sp 0000007f041f65f0 lr 0000007f0423de04 pc 0000007f0423f980
F DEBUG :
F DEBUG : backtrace:
F DEBUG : #00 pc 000000000003f980 /data/app/re.pwnme-7O3ynhSmMsg2_E5_uqbQxQ==/lib/arm64/libnative-lib.so
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The backtrace suggests that other checks are performed in the native library. By looking at the ELF&amp;rsquo;s constructors,
we can notice two functions that differ from those generated by the obfuscator:&lt;/p>
&lt;p>&lt;img src="elf_ctor.png" alt="ELF constructors involved in the detection">&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
&lt;code>.datadiv_decode13003153710004289592&lt;/code> functions are in the ELF constructors since they decode global strings that need to be
available as soon as the library is loaded.
&lt;/div>
&lt;/div>
&lt;p>By tracing these functions with
&lt;a href="https://qbdi.quarkslab.com/" target="_blank" rel="noopener">QBDI&lt;/a>, we quickly understand that &lt;span class="green">sub_9080&lt;/span> iterates over
&lt;code>/proc/self/maps&lt;/code> with the syscalls &lt;span class="blue">openat&lt;/span>/&lt;span class="hl-keyword">read&lt;/span>
that are located at the addresses &lt;span class="blue">0x009870&lt;/span> and &lt;span class="hl-keyword">0x00b448&lt;/span>.&lt;/p>
&lt;p>Then, we observe the following sequence:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x011fb0: syscall: openat(0xffffffffffffff9c, &amp;#39;/system/lib64/libc.so&amp;#39;)
0x012884: syscall: read(51, 0x7ffc006c58, 64): &amp;#39;ELF@)@8@&amp;#39;
0x013170: syscall: lseek(51, 0x112918, 0)
0x0145f8: syscall: read(51, 0x7ffc006c18, 64)
0x0145f8: syscall: read(51, 0x7ffc006c18, 64)
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;/ &amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;B88&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;J&amp;gt;&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;RoP)&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;\o((&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;io&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;xo0&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64)
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;Bxx`-&amp;#39;
0x0145f8: syscall: read(51, 0x7ffc006c18, 64): &amp;#39;PP`&amp;#39;
0x0151f4: malloc(0x18): 0x7f0c21f4c0
0x0156e4: syscall: lseek(51, 0x1a650, 0)
0x015a68: malloc(0x1e60): 0x7f0acb2000
0x015fa0: syscall: read(51, 0x7f0acb2000, 0x1e60): &amp;#39;{n@b r@ v@ z@ ~@ @ @&amp;#34; @B @b @ @ @ @ @ @&amp;#34; @B @b @ @ @ @ @ @&amp;#34; @B @b @ @ @ @ @ @&amp;#34; @B @b @ @ @ @ A A&amp;#34; AB Ab A A A A &amp;#34;A &amp;amp;A&amp;#34; *AB .Ab 2A 6A :A &amp;gt;A BA FA&amp;#34; JAB NAb RA VA ZA ^A bA fA&amp;#34; jAB nAb rA vA zA ~A A A&amp;#34; AB Ab A A A A A A&amp;#34; AB Ab A A A A A A&amp;#34; AB Ab A A A A A A&amp;#34; AB Ab A A A A B B&amp;#34; BB Bb B B B B &amp;#34;B &amp;amp;B&amp;#34; *BB .Bb 2B 6B :B &amp;gt;B BB FB&amp;#34; JBB NBb RB VB ZB ^B bB fB&amp;#34; jBB nBb rB vB zB ~B B B&amp;#34; BB Bb B B B B B B&amp;#34; B ...&amp;#39;
0x016cfc: free(0x7f0acb2000) -&amp;gt; {n@b r@ v@ z@ ~@ @ @&amp;#34; @B @b @ @ @ @ @ @&amp;#34; @B @b @ @ @ @ @ @&amp;#34; @B @b @ @ @ @ @ @&amp;#34; @B @b @ @ @ @ A A&amp;#34; AB Ab A A A A &amp;#34;A &amp;amp;A&amp;#34; *AB .Ab 2A 6A :A &amp;gt;A BA FA&amp;#34; JAB NAb RA VA ZA ^A bA fA&amp;#34; jAB nAb rA vA zA ~A A A&amp;#34; AB Ab A A A A A A&amp;#34; AB Ab A A A A A A&amp;#34; AB Ab A A A A A A&amp;#34; AB Ab A A A A B B&amp;#34; BB Bb B B B B &amp;#34;B &amp;amp;B&amp;#34; *BB .Bb 2B 6B :B &amp;gt;B BB FB&amp;#34; JBB NBb RB VB ZB ^B bB fB&amp;#34; jBB nBb rB vB zB ~B B B&amp;#34; BB Bb B B B B B B&amp;#34; B ...
0x017118: syscall: close(51)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From this output, we can infer the following logic:&lt;/p>
&lt;ol>
&lt;li>&lt;code>0x011fb0&lt;/code>: the function opens the libc&lt;/li>
&lt;li>&lt;code>0x012884&lt;/code>: it reads the ELF header&lt;/li>
&lt;li>&lt;code>0x013170&lt;/code>: it jumps to the ELF sections table&lt;/li>
&lt;li>&lt;code>0x0145f8&lt;/code>: it looks for the &lt;code>.plt&lt;/code> section&lt;/li>
&lt;li>&lt;code>0x015a68&lt;/code>, &lt;code>0x015fa0&lt;/code>: it reads the content of the &lt;code>.plt&lt;/code> section&lt;/li>
&lt;/ol>
&lt;p>These operations suggest that the function checks if the &lt;code>.plt&lt;/code> of &lt;code>/system/lib64/libc.so&lt;/code> is not tampered with.
In particular, if we use Frida on a libc&amp;rsquo;s function this check won&amp;rsquo;t pass.&lt;/p>
&lt;p>After this check, the function &lt;span class="green">sub_9080&lt;/span> spawns a thread:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x0195dc: pthread_create(0xf1079f10, 0x0, 0x1a690, 0x0)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The libc integrity check makes more sense as it is probably used to protect the library against a hook of &lt;code>pthread_create()&lt;/code>.&lt;/p>
&lt;p>The thread&amp;rsquo;s routine &lt;span class="red">sub_1a690&lt;/span> starts by making two calls to the mathematical function &lt;code>tan()&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x01b774: tan(0.): 0.
0x01b79c: tan(-7832.0): -0.00951489
0x01cc74: memcpy(0x7ffc006598, libnative-lib.so!0x1267f0, 80) -&amp;gt; !7Nl
0x01ceb8: rand()
0x01f774: tan(0.): 0.
0x01f79c: tan(-7832.0): -0.00951489
&lt;/code>&lt;/pre>&lt;/div>&lt;p>My understanding of these calls is that the application tries to protect against tools that would not support
floating-point instructions such as &lt;code>FCMP&lt;/code> or &lt;code>FMOV&lt;/code>. In addition, I think that if we mock the behavior of
&lt;code>tan()&lt;/code> with a constant value it would trigger a crash.&lt;/p>
&lt;p>&lt;img src="tan_instruction.png" alt="tan">&lt;/p>
&lt;p>Then it follows a check of &lt;code>TracerPid&lt;/code> value in &lt;code>/proc/self/status&lt;/code>. This value is set when
the process is ptrace-debugged (which is the case with gdb).
Dynamically, we observe syscalls that open &lt;code>/proc/self/status&lt;/code> and read the content
byte-per-byte:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x020ee0: syscall: openat(0xffffffffffffff9c, &amp;#39;/proc/self/status&amp;#39;): 51
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;N&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;a&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;m&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;e&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;:&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1)
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;r&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;e&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;.&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;p&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;w&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;n&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;m&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;e&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1)
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;S&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;t&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;a&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;t&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;e&amp;#39;
0x0231e8: syscall: read(51, 0x7ffc00656c, 1): &amp;#39;:&amp;#39;
...
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="anti-frida-1">Anti-Frida #1&lt;/h2>
&lt;p>Still in the thread&amp;rsquo;s routine &lt;span class="red">sub_1a690&lt;/span>, the function checks if Frida is running by looking
at all the values of &lt;code>/proc/self/task/&amp;lt;tid&amp;gt;/status&lt;/code> and by checking if one of the names is &lt;span class="red">&lt;b>&lt;u>gmain&lt;/u>&lt;/b>&lt;/span>.
It turns out that it&amp;rsquo;s the case when Frida is used in the application :-)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x0368e4: snprintf(&amp;#39;/proc/self/task/9719/status&amp;#39;, &amp;#39;/proc/self/task/%s/status&amp;#39;): &amp;#39;/proc/self/task/9719/status&amp;#39;
0x036a1c: syscall: openat(0xffffffffffffff9c, &amp;#39;/proc/self/task/9719/status&amp;#39;)
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;N&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;a&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;m&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;e&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;:&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1)
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;g&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;m&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;a&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;i&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1): &amp;#39;n&amp;#39;
0x03897c: syscall: read(73, 0x7ffc400af4, 1)
0x03897c: closedir()
# Crash!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To bypass this check, one can statically patch the syscall or we can dynamically
change the behavior of &lt;code>snprintf(..., '/proc/self/task/%s/status')&lt;/code> in order to &lt;strong>always&lt;/strong> returns the same status (e.g. &lt;code>/proc/self/task/123/status&lt;/code>).
Concretely, it could be done by hooking &lt;code>snprintf&lt;/code> and by forcing the &lt;em>output&lt;/em> string to &lt;code>/proc/self/task/123/status&lt;/code>.&lt;/p>
&lt;h2 id="anti-frida-2">Anti-Frida #2&lt;/h2>
&lt;p>Still in the &lt;span class="red">sub_1a690&lt;/span> function, the anti-frida checks continue by inspecting the file descriptors
of the process. It iterates over &lt;code>/proc/self/fd/%s&lt;/code> and looks at the underlying symlink.&lt;/p>
&lt;p>Frida &lt;span class="blue">server&lt;/span> &amp;mdash; which is running globally on the device &amp;mdash; and Frida agent &amp;mdash; which is injected in the
process &amp;mdash; communicate with named pipes that are associated with a file descriptor.&lt;/p>
&lt;p>If Frida server is running, we can observe the following values:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x04308c: lstat(&amp;#39;/proc/self/fd/32&amp;#39;)
0x043448: syscall: readlinkat(0xffffffffffffff9c, &amp;#39;/proc/self/fd/32&amp;#39;, 0x7ffbffdc10, 256): &amp;#39;anon_inode:[eventfd]&amp;#39;
0x041844: readdir(&amp;#39;33&amp;#39;)
0x043078: snprintf(&amp;#39;/proc/self/fd/33&amp;#39;, &amp;#39;/proc/self/fd/%s&amp;#39;): &amp;#39;/proc/self/fd/33&amp;#39;
0x04308c: lstat(&amp;#39;/proc/self/fd/33&amp;#39;)
0x043448: syscall: readlinkat(0xffffffffffffff9c, &amp;#39;/proc/self/fd/33&amp;#39;, 0x7ffbffdc10, 256): &amp;#39;anon_inode:[eventfd]&amp;#39;
0x041844: readdir(&amp;#39;34&amp;#39;)
0x043078: snprintf(&amp;#39;/proc/self/fd/34&amp;#39;, &amp;#39;/proc/self/fd/%s&amp;#39;): &amp;#39;/proc/self/fd/34&amp;#39;
0x04308c: lstat(&amp;#39;/proc/self/fd/34&amp;#39;)
0x043448: syscall: readlinkat(0xffffffffffffff9c, &amp;#39;/proc/self/fd/34&amp;#39;, 0x7ffbffdc10, 256): &amp;#39;/data/local/tmp/re.frida.server/linjector-500&amp;#39;
# Crash!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this case, the file descriptor &lt;code>34&lt;/code> is associated with &lt;code>/data/local/tmp/re.frida.server/linjector-500&lt;/code>
which triggers the detection and the application crashes.&lt;/p>
&lt;p>As for &lt;code>/proc/self/task/&amp;lt;tid&amp;gt;/status&lt;/code>, one can disable this check by &lt;strong>statically patching&lt;/strong> the syscalls or
by &lt;strong>dynamically changing&lt;/strong> the result of &lt;code>readlinkat()&lt;/code>. For instance, we can use
&lt;a href="https://qbdi.quarkslab.com/" target="_blank" rel="noopener">QBDI&lt;/a> to
instrument syscall instructions and process the result of &lt;code>readlinkat()&lt;/code> in an user callback:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">
vm.addMnemonicCB(&lt;span style="color:#e6db74">&amp;#34;SVC&amp;#34;&lt;/span>, POST_INST,
[] (VMInstanceRef vm, GPRState&lt;span style="color:#f92672">*&lt;/span> gprState, FPRState&lt;span style="color:#f92672">*&lt;/span>, &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> data) {
&lt;span style="color:#66d9ef">if&lt;/span> (gprState&lt;span style="color:#f92672">-&amp;gt;&lt;/span>x8 &lt;span style="color:#f92672">!=&lt;/span> __NR_readlinkat) {
&lt;span style="color:#66d9ef">return&lt;/span> VMAction&lt;span style="color:#f92672">::&lt;/span>CONTINUE;
}
std&lt;span style="color:#f92672">::&lt;/span>string buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(gprState&lt;span style="color:#f92672">-&amp;gt;&lt;/span>x2);
&lt;span style="color:#66d9ef">if&lt;/span> (buf.find(&lt;span style="color:#e6db74">&amp;#34;re.frida.server&amp;#34;&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">::&lt;/span>npos) {
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string FAKE_VALUE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;anon_inode:[eventfd]&amp;#34;&lt;/span>;
&lt;span style="color:#75715e">// Bypass Frida detection!
&lt;/span>&lt;span style="color:#75715e">&lt;/span> memcpy(
&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(gprState&lt;span style="color:#f92672">-&amp;gt;&lt;/span>x2),
&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(FAKE_VALUE.c_str()),
FAKE_VALUE.size() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
);
gprState&lt;span style="color:#f92672">-&amp;gt;&lt;/span>x0 &lt;span style="color:#f92672">=&lt;/span> FAKE_VALUE.size() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">return&lt;/span> VMAction&lt;span style="color:#f92672">::&lt;/span>CONTINUE;
}, ctx);
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="anti-frida-3-">Anti-Frida #3 ?&lt;/h2>
&lt;p>I&amp;rsquo;m not sure if the following calls sequence is used to check the libc&amp;rsquo;s integrity against Frida but
at the end of the thread&amp;rsquo;s routine, we can observe these syscalls:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x048ff0: syscall: openat(0xffffffffffffff9c, &amp;#39;/proc/self/maps&amp;#39;): 51
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;1&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;2&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;c&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;0&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;0&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;0&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;0&amp;#39;
0x04ae6c: syscall: read(51, 0x7ffc006578, 1): &amp;#39;0&amp;#39;
...
0x0513f8: sscanf(&amp;#39;7fa65c0000-7fa65dc000 r-xp 00000000 08:07 1275/system/lib64/libc.so&amp;#39;, &amp;#39;%lx-%lx %s %s %s %s %s&amp;#39;)
0x056034: syscall: close(51)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The result of &lt;code>sscanf()&lt;/code> could be used to check the page permissions (e.g. &lt;code>r&lt;/code>&lt;span class="blue">w&lt;/span>&lt;code>xp&lt;/code>)
or to the libc&amp;rsquo;s base address (to check if it is consistent).&lt;/p>
&lt;h2 id="anti-root">Anti-Root&lt;/h2>
&lt;p>In addition to the root-beer detection, the library embeds another root detection located in the &lt;strong>second&lt;/strong> ELF constructor.
This constructor &amp;mdash; &lt;span class="yellow">sub_77D14&lt;/span> &amp;mdash; performs the same early checks as the first constructor
on the libc&amp;rsquo;s &lt;code>.plt&lt;/code> integrity before spawning another thread routine, &lt;span class="yellow">sub_98c00&lt;/span>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x08861c: pthread_create(0xfa780b70, 0x0, 0x98c00, 0x0)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="ctor_pthread.png" alt="ELF constructors: anti-frida and anti-root">&lt;/p>
&lt;p>By tracing the thread&amp;rsquo;s routine, we notice that it checks if &lt;code>su&lt;/code> files are present on the device through
three different calls:&lt;/p>
&lt;ol>
&lt;li>One call to &lt;code>open()&lt;/code>: &lt;span class="hl-literal">0x099180: open(&lt;span class="hl-strings">'/system/xbin/su'&lt;/span>)&lt;/span>&lt;/li>
&lt;li>One syscall to &lt;code>openat()&lt;/code>: &lt;span class="hl-literal">0x0992a4: syscall: openat(&amp;hellip;, &lt;span class="hl-strings">'/data/su'&lt;/span>)&lt;/span>&lt;/li>
&lt;li>One syscall to &lt;code>faccessat()&lt;/code>: &lt;span class="hl-literal">0x0993f0: syscall: faccessat(&lt;span class="hl-strings">'/sbin/su'&lt;/span>)&lt;/span>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x099180: open(&amp;#39;/data/local/su&amp;#39;): -1
0x0992a4: syscall: openat(0xffffffffffffff9c, &amp;#39;/data/local/su&amp;#39;): -2
0x0993f0: syscall: faccessat(&amp;#39;/data/local/su&amp;#39;): -2
0x099180: open(&amp;#39;/data/local/bin/su&amp;#39;): -1
0x0992a4: syscall: openat(0xffffffffffffff9c, &amp;#39;/data/local/bin/su&amp;#39;): -2
0x0993f0: syscall: faccessat(&amp;#39;/data/local/bin/su&amp;#39;): -2
0x099180: open(&amp;#39;/data/local/xbin/su&amp;#39;): -1
0x0992a4: syscall: openat(0xffffffffffffff9c, &amp;#39;/data/local/xbin/su&amp;#39;): -2
0x0993f0: syscall: faccessat(&amp;#39;/data/local/xbin/su&amp;#39;): -2
0x099180: open(&amp;#39;/sbin/su&amp;#39;): 51
0x0992a4: syscall: openat(0xffffffffffffff9c, &amp;#39;/sbin/su&amp;#39;): 52
0x0993f0: syscall: faccessat(&amp;#39;/sbin/su&amp;#39;): 52
Crash!
&lt;/code>&lt;/pre>&lt;/div>&lt;p>By forcing the results of these functions to &lt;code>-1&lt;/code> or &lt;code>-2&lt;/code>, we can disable the checks.&lt;/p>
&lt;p>Here is the list of the su-files that are used in this detection:&lt;/p>
&lt;ul>
&lt;li>&lt;span class="hl-strings">/data/local/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/data/local/bin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/data/local/xbin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/sbin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/su/bin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/system/bin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/system/bin/.ext/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/system/bin/failsafe/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/system/sd/xbin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/system/usr/we-need-root/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/system/xbin/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/cache/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/data/su&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-strings">/dev/su&lt;/span>&lt;/li>
&lt;/ul>
&lt;p>At the end of the thread&amp;rsquo;s routine, we can also observe the following calls that
are probably used to check if the application is running on a real Android system.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">0x099e30: syscall: faccessat(&amp;#39;/system&amp;#39;)
0x099e30: syscall: faccessat(&amp;#39;/system/bin&amp;#39;)
0x099e30: syscall: faccessat(&amp;#39;/system/sbin&amp;#39;)
0x099e30: syscall: faccessat(&amp;#39;/system/xbin&amp;#39;)
0x099e30: syscall: faccessat(&amp;#39;/vendor/bin&amp;#39;)
0x099e30: syscall: faccessat(&amp;#39;/sbin&amp;#39;)
0x099e30: syscall: faccessat(&amp;#39;/etc&amp;#39;)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="static-bypass-with-lief">Static bypass with LIEF&lt;/h2>
&lt;p>In the previous sections, we described the anti-root, anti-debug and anti-frida checks
made in the ELF constructors. The &lt;strong>same&lt;/strong> dynamic checks are also performed in the &lt;code>gXftm3iswpkVgBNDUp&lt;/code> function
at the following locations:&lt;/p>
&lt;ul>
&lt;li>&lt;span class="hl-keyword">0x09f2f8&lt;/span>: &lt;span class="hl-literal">/proc/self/status&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-keyword">0x0d4840&lt;/span>: &lt;span class="hl-literal">/proc/self/fd/&lt;/span>&lt;/li>
&lt;li>&lt;span class="hl-keyword">0x0dec8c&lt;/span>: &lt;span class="hl-literal">/proc/self/task/&amp;lt;tid&amp;gt;/status&lt;/span>&lt;/li>
&lt;/ul>
&lt;p>While the checks in &lt;code>gXftm3iswpkVgBNDUp&lt;/code> can be dynamically disabled when instrumenting the function,
the checks in the ELF constructors are annoying.&lt;/p>
&lt;p>One way to disable the checks in the thread&amp;rsquo;s routines is to disable the &lt;code>pthread_create(...)&lt;/code>. It can
be achieved by patching the &lt;code>.plt&lt;/code> entry associated with the function:&lt;/p>
&lt;pre>&lt;code class="language-armasm" data-lang="armasm">mov x0, xzr;
ret;
&lt;/code>&lt;/pre>&lt;p>Thanks to &lt;code>llvm-mc&lt;/code>, we can get the raw bytes of these instructions:&lt;/p>
&lt;pre>&lt;code class="language-console" data-lang="console">$ echo &amp;quot;mov x0, xzr;ret;&amp;quot;|llvm-mc -arch=aarch64 -show-encoding
.text
mov x0, xzr // encoding: [0xe0,0x03,0x1f,0xaa]
ret // encoding: [0xc0,0x03,0x5f,0xd6]
&lt;/code>&lt;/pre>&lt;p>Finally, we can patch the &lt;code>.plt&lt;/code> with
&lt;a href="https://lief.quarkslab.com" target="_blank" rel="noopener">LIEF&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> lief
lib &lt;span style="color:#f92672">=&lt;/span> lief&lt;span style="color:#f92672">.&lt;/span>parse(&lt;span style="color:#e6db74">&amp;#34;./libnative-lib.so&amp;#34;&lt;/span>)
lib&lt;span style="color:#f92672">.&lt;/span>patch_address(&lt;span style="color:#ae81ff">0x5870&lt;/span>, [&lt;span style="color:#ae81ff">0xe0&lt;/span>,&lt;span style="color:#ae81ff">0x03&lt;/span>,&lt;span style="color:#ae81ff">0x1f&lt;/span>,&lt;span style="color:#ae81ff">0xaa&lt;/span>])
lib&lt;span style="color:#f92672">.&lt;/span>patch_address(&lt;span style="color:#ae81ff">0x5874&lt;/span>, [&lt;span style="color:#ae81ff">0xc0&lt;/span>,&lt;span style="color:#ae81ff">0x03&lt;/span>,&lt;span style="color:#ae81ff">0x5f&lt;/span>,&lt;span style="color:#ae81ff">0xd6&lt;/span>])
lib&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;./libnative-lib-patched.so&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="patching.png" alt="pthread_create patches">&lt;/p>
&lt;p>Using these patches and the Frida script exposed in the first section, we are able to &lt;strong>load&lt;/strong> the application but the other
detections are triggered in &lt;code>gXftm3iswpkVgBNDUp&lt;/code>. Nevertheless, with
the Frida&amp;rsquo;s stalker or QBDI we can trace the instructions and disable the other checks.&lt;/p>
&lt;p>If one wants to completely bypass all the protections statically, here are the patches:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#f92672">import&lt;/span> lief
lib &lt;span style="color:#f92672">=&lt;/span> lief&lt;span style="color:#f92672">.&lt;/span>parse(&lt;span style="color:#e6db74">&amp;#34;./libnative-lib.so&amp;#34;&lt;/span>)
&lt;span style="color:#75715e"># Keys are str objects for a better understanding :)&lt;/span>
INST &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#e6db74">&amp;#34;mov x0, #0&amp;#34;&lt;/span>: [&lt;span style="color:#ae81ff">0xe0&lt;/span>, &lt;span style="color:#ae81ff">0x03&lt;/span>, &lt;span style="color:#ae81ff">0x1f&lt;/span>, &lt;span style="color:#ae81ff">0xaa&lt;/span>],
&lt;span style="color:#e6db74">&amp;#34;ret&amp;#34;&lt;/span>: [&lt;span style="color:#ae81ff">0xc0&lt;/span>, &lt;span style="color:#ae81ff">0x03&lt;/span>, &lt;span style="color:#ae81ff">0x5f&lt;/span>, &lt;span style="color:#ae81ff">0xd6&lt;/span>],
&lt;span style="color:#e6db74">&amp;#34;nop&amp;#34;&lt;/span>: [&lt;span style="color:#ae81ff">0x1f&lt;/span>, &lt;span style="color:#ae81ff">0x20&lt;/span>, &lt;span style="color:#ae81ff">0x03&lt;/span>, &lt;span style="color:#ae81ff">0xd5&lt;/span>],
}
PATCHES &lt;span style="color:#f92672">=&lt;/span> [
&lt;span style="color:#75715e"># Patch the .plt entry of pthread_create&lt;/span>
(&lt;span style="color:#ae81ff">0x5870&lt;/span>, INST[&lt;span style="color:#e6db74">&amp;#34;mov x0, #0&amp;#34;&lt;/span>]),
(&lt;span style="color:#ae81ff">0x5874&lt;/span>, INST[&lt;span style="color:#e6db74">&amp;#34;ret&amp;#34;&lt;/span>]),
&lt;span style="color:#75715e"># Disable anti-frida checks&lt;/span>
(&lt;span style="color:#ae81ff">0x0d718c&lt;/span>, INST[&lt;span style="color:#e6db74">&amp;#34;mov x0, #0&amp;#34;&lt;/span>]), &lt;span style="color:#75715e"># /proc/self/fd : patch the result of readlinkat syscall&lt;/span>
(&lt;span style="color:#ae81ff">0x0e1940&lt;/span>, INST[&lt;span style="color:#e6db74">&amp;#34;mov x0, #0&amp;#34;&lt;/span>]), &lt;span style="color:#75715e"># /proc/self/task/&amp;lt;tid&amp;gt;/status: patch the result of read syscall&lt;/span>
&lt;span style="color:#75715e"># Disable .text integrity checks&lt;/span>
(&lt;span style="color:#ae81ff">0xB64D0&lt;/span>, INST[&lt;span style="color:#e6db74">&amp;#34;nop&amp;#34;&lt;/span>]),
]
&lt;span style="color:#66d9ef">for&lt;/span> patch &lt;span style="color:#f92672">in&lt;/span> PATCHES:
lib&lt;span style="color:#f92672">.&lt;/span>patch_address(&lt;span style="color:#f92672">*&lt;/span>patch)
lib&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#34;libnative-lib.so&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When writing this write-up, I realized that patching the syscalls involved in the anti-frida (&lt;span class="hl-literal">/proc/self/fd/&lt;/span> and &lt;span class="hl-literal">/proc/self/task/&amp;lt;tid&amp;gt;/status&lt;/span>)
makes the application crash.&lt;/p>
&lt;p>It turns out that the library seems to implement &lt;strong>code integrity on the &lt;code>.text&lt;/code> section&lt;/strong> that I didn&amp;rsquo;t notice when running
the function through QBDI.
Nevertheless, by tracing the basic block&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>
we can identify the basic block involved in the integrity check and patch it.&lt;/p>
&lt;p>&lt;img src="code_integrity.png" alt="Code integrity patches">&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The scripts and the patched library are available &lt;a href="https://github.com/romainthomas/r2pay">here &lt;i class="fab fa-github">&lt;/i>&lt;/a>.
&lt;/div>
&lt;/div>
&lt;p>Regarding &lt;code>JNI_OnLoad()&lt;/code>, a trace generated with
&lt;a href="https://github.com/QBDI/examples/blob/d589d28b237f46d16cab3b11aa36bbb51102e307/packer-android-x86/src/libshellx_qbdi.cpp#L18-L85" target="_blank" rel="noopener">QBDI&amp;rsquo;s ExecBroker&lt;/a>
leads to following result:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">JNI_OnLoad() {
&lt;span style="color:#ae81ff">0x09af3c&lt;/span>&lt;span style="color:#f92672">:&lt;/span> GetEnv(&lt;span style="color:#ae81ff">0x7fcb507460&lt;/span>, &lt;span style="color:#ae81ff">0x10006&lt;/span>)
&lt;span style="color:#ae81ff">0x09b0ac&lt;/span>&lt;span style="color:#f92672">:&lt;/span> FindClass(&lt;span style="color:#e6db74">&amp;#34;re/pwnme/MainActivity&amp;#34;&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">537&lt;/span>
&lt;span style="color:#ae81ff">0x09b1b4&lt;/span>&lt;span style="color:#f92672">:&lt;/span> RegisterNatives()
gXftm3iswpkVgBNDUp ([BB)[B &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;libnative-lib.so@0x9b41c&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we can extract the function&amp;rsquo;s offset: &lt;span class="blue">gXftm3iswpkVgBNDUp&lt;/span>: &lt;span class="red">0x9b41c&lt;/span>.&lt;/p>
&lt;h2 id="summary--conclusion">Summary &amp;amp; Conclusion&lt;/h2>
&lt;p>Whilst Frida detections are usually based on sockets and library names in &lt;code>/proc/self/maps&lt;/code>,
this challenge introduces two detections based on named pipes:&lt;code>/proc/self/fd&lt;/code> and thread status: &lt;code>/proc/self/task/&amp;lt;tid&amp;gt;/status&lt;/code>
which are pretty cool :-)&lt;/p>
&lt;p>These checks are performed in two locations:&lt;/p>
&lt;ol>
&lt;li>The ELF constructors&lt;/li>
&lt;li>The function &lt;code>gXftm3iswpkVgBNDUp()&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>The implementation in the ELF constructors might be tricky to analyse since the functions are called before &lt;strong>any&lt;/strong>
other classical functions (which includes &lt;code>JNI_OnLoad()&lt;/code>). Nevertheless, thanks to the interface of the ELF loader,
it exposes the function &lt;code>call_array(...)&lt;/code>&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> which is handy to process the ELF constructors.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
This function is mangled as &lt;code>__dl__ZL10call_arrayIPFviPPcS1_EEvPKcPT_mbS5_&lt;/code> in &lt;code>/system/bin/linker64&lt;/code>
&lt;/div>
&lt;/div>
&lt;p>&lt;img src="protection_overview.png" alt="Overview of the anti-root and anti-frida">&lt;/p>
&lt;p>Since QBDI is not detected in this challenge, it&amp;rsquo;s a good opportunity to give it a try:&lt;/p>
&lt;center>&lt;i class="fab fa-github">&lt;/i> &lt;a href="https://github.com/QBDI/QBDI">https://github.com/QBDI/QBDI&lt;/a>&lt;/center>
&lt;h2 id="acknowledgments">Acknowledgments&lt;/h2>
&lt;p>Thanks to &lt;u>Eduardo Novella&lt;/u> (
&lt;a href="https://twitter.com/enovella_" target="_blank" rel="noopener">@enovella_&lt;/a>)
and &lt;u>Gautam Arvind&lt;/u> (
&lt;a href="https://twitter.com/darvincisec" target="_blank" rel="noopener">@darvincisec&lt;/a>) for this interesting and realistic challenge they created!&lt;/p>
&lt;p>Also thanks to &lt;u>
&lt;a href="https://www.quarkslab.com" target="_blank" rel="noopener">Quarkslab&lt;/a>&lt;/u> that allowed this publication.
For those who are interested in similar topics, you can take a look at the Quarkslab&amp;rsquo;s
&lt;a href="https://blog.quarkslab.com/" target="_blank" rel="noopener">blog&lt;/a>.&lt;/p>
&lt;h3 id="references">References&lt;/h3>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>
&lt;a href="https://github.com/GoSSIP-SJTU/Armariris" target="_blank" rel="noopener">GoSSIP-SJTU/Armariris&lt;/a> -
&lt;a href="https://github.com/GoSSIP-SJTU/Armariris/blob/0cba41329244a29c7cb94e25458191b68967b6e8/lib/Transforms/Obfuscation/StringObfuscation.cpp#L140" target="_blank" rel="noopener">&lt;code>StringObfuscation.cpp#L140&lt;/code>&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a href="https://developer.android.com/training/articles/perf-jni#native-libraries">https://developer.android.com/training/articles/perf-jni#native-libraries&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>
&lt;a href="https://github.com/QBDI/QBDI/blob/a20653f07df3ae78250e7ecf28ed699b2d727027/include/QBDI/VM.h#L296-L305" target="_blank" rel="noopener">&lt;code>addVMEventCB(VMEvent::BASIC_BLOCK_ENTRY, ...);&lt;/code>&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>
&lt;a href="https://android.googlesource.com/platform/bionic/&amp;#43;/refs/tags/android-9.0.0_r60/linker/linker_soinfo.cpp#420" target="_blank" rel="noopener">&lt;code>linker/linker_soinfo.cpp:420&lt;/code>&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>HITB 2015 Write-up - Crypto 300</title><link>/post/writeup-hitb2015-crypto300/</link><pubDate>Tue, 03 Nov 2015 00:00:00 +0100</pubDate><guid>/post/writeup-hitb2015-crypto300/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>The crypto 300 challenge was about RSA with a special generation of the prime numbers $p$ and $q$.
We were given a mail
&lt;a href="mail.msg">mail.msg&lt;/a> which has been encrypted with RSA and whose the public key is in the
&lt;a href="hitbctf.crt">hitbctf.crt&lt;/a> certificate.&lt;/p>
&lt;h2 id="rsas-parameters-construction">RSA&amp;rsquo;s Parameters Construction&lt;/h2>
&lt;p>The modulus $N$ is built by choosing randomly a first prime number $p$, the second prime number $q$ is constructed in the following way:&lt;/p>
&lt;p>$$\alpha \cdot (p - 1) \equiv 1 \pmod{e}$$&lt;/p>
&lt;p>$$q = (p\alpha \bmod e) + k\cdot e$$&lt;/p>
&lt;p>$k$ is a positive integer such as $q$ is a prime number and $e$ is the public exponent which is also a random prime number.&lt;/p>
&lt;p>The following code is the implementation in Python:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">gen_rsa_parameters&lt;/span>():
r &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>urandom(&lt;span style="color:#ae81ff">63&lt;/span>)
e &lt;span style="color:#f92672">=&lt;/span> int(r&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#39;hex&amp;#39;&lt;/span>), &lt;span style="color:#ae81ff">16&lt;/span>)
e &lt;span style="color:#f92672">=&lt;/span> next_prime(e)
r &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>urandom(&lt;span style="color:#ae81ff">64&lt;/span>)
p &lt;span style="color:#f92672">=&lt;/span> int(r&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#39;hex&amp;#39;&lt;/span>), &lt;span style="color:#ae81ff">16&lt;/span>)
p &lt;span style="color:#f92672">=&lt;/span> next_prime(p)
q &lt;span style="color:#f92672">=&lt;/span> (p&lt;span style="color:#f92672">*&lt;/span>modinv(p&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, e)&lt;span style="color:#f92672">%&lt;/span>e)
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">not&lt;/span> is_prime(q):
q &lt;span style="color:#f92672">+=&lt;/span> e
N &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">*&lt;/span>q
phi &lt;span style="color:#f92672">=&lt;/span> (p&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">*&lt;/span>(q&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
d &lt;span style="color:#f92672">=&lt;/span> modinv(e,phi)
&lt;span style="color:#66d9ef">return&lt;/span> N,e,d,p,q
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="theoretical-attack">Theoretical attack&lt;/h2>
&lt;p>Let&amp;rsquo;s $N^{\prime} = N \bmod{e}$. So we have&lt;/p>
&lt;p>\begin{eqnarray}
N^{\prime} &amp;amp; \equiv &amp;amp; p \cdot q \pmod{e} \\\&lt;br>
&amp;amp; \equiv &amp;amp; p \cdot ((p\alpha \bmod e) + k\cdot e) \pmod{e} \\\&lt;br>
&amp;amp; \equiv &amp;amp; p^2\alpha \pmod{e} \\\&lt;br>
\end{eqnarray}&lt;/p>
&lt;p>We have $\alpha$ in the equation so we can introduce $p - 1$ to remove $\alpha$&lt;/p>
&lt;p>\begin{eqnarray}
N^{\prime} &amp;amp; \equiv &amp;amp; (p - 1 + 1)^2\alpha \pmod{e} \\\&lt;br>
&amp;amp; \equiv &amp;amp; (p - 1)^2\alpha + 2(p - 1)\alpha + \alpha \pmod{e} \\\&lt;br>
&amp;amp; \equiv &amp;amp; (p - 1) + 2 + \alpha \pmod{e} \\\&lt;br>
(p - 1)N^{\prime} &amp;amp; \equiv &amp;amp; (p - 1)^2 + 2(p - 1) + 1 \pmod{e}
\end{eqnarray}&lt;/p>
&lt;p>$$\boxed{(p - 1)^2 - (N^{\prime} - 2)(p - 1) + 1 \equiv 0 \pmod{e}}$$&lt;/p>
&lt;p>Now we have a quadratic equation which only depends on $p$.&lt;/p>
&lt;p>Let&amp;rsquo;s $X = p - 1$ and suppose that $N^{\prime} - 2$ is even and $N^{\prime} - 2 = 2b$.&lt;/p>
&lt;p>\begin{eqnarray}
X^2 - 2bX + 1 &amp;amp; \equiv &amp;amp; 0 &amp;amp; \pmod{e} \\\&lt;br>
(X - b)^2 - b^2 + 1 &amp;amp; \equiv &amp;amp; 0 &amp;amp; \pmod{e}\\\&lt;br>
(X - b)^2 &amp;amp; \equiv &amp;amp; b^2 - 1 &amp;amp; \pmod{e}
\end{eqnarray}&lt;/p>
&lt;p>by using
&lt;a href="https://en.wikipedia.org/wiki/Quadratic_residue" target="_blank" rel="noopener">quadratic residue&lt;/a> we can find a solution. We can also use &lt;em>SAGE&lt;/em> and the &lt;code>sqrt()&lt;/code> function:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">Np &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">%&lt;/span> e
b &lt;span style="color:#f92672">=&lt;/span> (Np &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
p &lt;span style="color:#f92672">=&lt;/span> Mod(pow(b, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, e)&lt;span style="color:#f92672">.&lt;/span>sqrt() &lt;span style="color:#f92672">+&lt;/span> b &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>At this point, we find $p \bmod{e}$ but not $p$ !&lt;/p>
&lt;p>I tried to find $p$ by adding some $e$ but the &lt;em>distance&lt;/em> between $p$ and $p \bmod{e}$ is huge. So I had to find another way.&lt;/p>
&lt;p>By knowing $p \bmod{e}$ we can compute $\alpha$. Remember $$\alpha \cdot (p - 1) \equiv 1 \pmod{e}$$ and by having $\alpha$ and $p \bmod{e}$ we can brute force $q$ by adding $e$ until $(p\alpha \bmod e) + k\cdot e$ is prime and it divide $N$.&lt;/p>
&lt;p>We did the assumption that $N^{\prime} - 2$ has to be even (so $N^{\prime}$ must be even) and in the certificate $N^{\prime}$ is even so everything is right.&lt;/p>
&lt;h2 id="pratical-attack">Pratical Attack&lt;/h2>
&lt;p>First we have to extract the modulus $N$ and the public key $e$ from the certificate:&lt;/p>
&lt;pre>&lt;code class="language-console" data-lang="console">$ openssl x509 -in hitbctf.crt -text -noout
Certificate:
Data:
Version: 1 (0x0)
Serial Number: 18379438180976429416 (0xff10e1a5ac5a0968)
Signature Algorithm: sha1WithRSAEncryption
Issuer: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF
Validity
Not Before: May 24 09:58:26 2015 GMT
Not After : May 23 09:58:26 2016 GMT
Subject: C=NL, ST=Noord-Holland, L=Amsterdam, O=HITB, OU=CTF
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (1024 bit)
Modulus:
00:e6:eb:89:c1:8d:49:c9:a2:02:2b:e0:b4:65:14:
6e:0f:90:45:1e:a3:4c:6b:60:56:00:4e:bd:15:59:
55:b1:35:96:c2:d6:83:ad:2f:23:6b:0b:2c:0e:0b:
88:83:b5:d6:cb:8a:0b:4f:f9:b7:eb:64:8c:95:2b:
6b:ef:5a:6f:04:f5:64:17:f5:1c:a9:14:d9:ea:73:
e7:dd:c5:f2:0d:ce:c3:9c:e8:4b:72:2a:0c:f3:d8:
5e:80:ce:78:64:63:e1:44:f6:1d:b5:9c:cf:45:ff:
0e:d3:7f:d0:ce:bd:37:a5:8d:8a:4b:08:33:9e:a3:
2c:bc:ab:61:64:03:fd:2c:c5
Exponent:
69:60:2d:93:8a:81:5f:14:cf:9f:b8:36:c2:e0:4d:
4d:De:82:ba:fc:8d:56:c2:6d:8c:89:ef:3c:40:69:
5d:d5:d4:ef:a7:36:36:43:15:14:95:f3:8c:bf:24:
ae:94:30:92:40:79:12:00:1b:17:f5:53:33:9e:92:
70:70:49
Signature Algorithm: sha1WithRSAEncryption
17:2b:ea:be:90:ad:98:f2:2b:ff:f5:61:d3:ea:af:fb:35:3a:
67:10:91:13:db:60:55:d9:09:8b:c2:1a:cf:6b:c6:1f:f2:10:
7a:d1:7b:9d:ff:10:f2:f2:c0:a9:f5:aa:2e:09:93:40:88:92:
7d:98:ff:e1:cb:dc:db:35:8d:e0:4b:21:99:76:bf:db:04:a2:
62:a4:18:4e:fc:bb:a7:53:be:6a:a1:ef:ec:15:86:c1:f1:1e:
87:6a:e9:af:fe:d1:08:eb:de:22:28:c4:5e:be:f1:41:0a:ca:
cf:cf:da:63:b1:c1:56:e8:0c:8e:56:7f:08:94:0d:2b:2a:08:
&lt;/code>&lt;/pre>&lt;p>&lt;code>N = 1621575882314321757502664197090844942567381491984167028188381926885851&lt;/code>
&lt;code>995558397927547394115469298694885747314992315746872071523931715177680193273&lt;/code>
&lt;code>386465775883129725436206653605910592810579794603402792446164893148622893121&lt;/code>
&lt;code>957048204358672599654432857497196823273138934901636721473789115585263150131&lt;/code>
&lt;code>66594183212229&lt;/code>&lt;/p>
&lt;p>&lt;code>e = 21558488234539889837938770635971330903489839146766895224490179041465516&lt;/code>
&lt;code>1931455822669631548838317075220811407344210520390992334648372016602816069805&lt;/code>
&lt;code>30249&lt;/code>&lt;/p>
&lt;p>With SAGE:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">sage: Np &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">%&lt;/span> e
sage: b &lt;span style="color:#f92672">=&lt;/span> (Np &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
sage: pp &lt;span style="color:#f92672">=&lt;/span> int(Mod(pow(b, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, e)&lt;span style="color:#f92672">.&lt;/span>sqrt()) &lt;span style="color:#f92672">+&lt;/span> b &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
sage: alpha &lt;span style="color:#f92672">=&lt;/span> inverse_mod(int(X), int(e))
sage: q &lt;span style="color:#f92672">=&lt;/span> (pp &lt;span style="color:#f92672">*&lt;/span> alpha) &lt;span style="color:#f92672">%&lt;/span> e
sage: &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">not&lt;/span> is_prime(q) &lt;span style="color:#f92672">and&lt;/span> N &lt;span style="color:#f92672">%&lt;/span> q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;span style="color:#f92672">....&lt;/span>: q &lt;span style="color:#f92672">+=&lt;/span> e
sage: p &lt;span style="color:#f92672">=&lt;/span> N &lt;span style="color:#f92672">/&lt;/span> q
sage: p
&lt;span style="color:#ae81ff">13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641&lt;/span>
sage: q
&lt;span style="color:#ae81ff">12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can now generate the private key by using
&lt;a href="rsatool.py">rsatool&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ ./rsatools.py -o private.pem &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>-e &lt;span style="color:#ae81ff">21558488234539889837938770635971330903489839146766895224490179041465516193145582266963154883831707522081140734421052039099233464837201660281606980530249&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>-p &lt;span style="color:#ae81ff">13317713478157317654574552532079837937895228108820477140030796245493222349714497856652987583926206280627498615972491072112647669795345566943409669535038641&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;span style="color:#ae81ff">&lt;/span>-q &lt;span style="color:#ae81ff">12176083266650126897170100375931110708350668494730113414987801764299563774952801449439933220072280766145748279998832962142839152786620322097065894585706069&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Finally, we can decrypt the message:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">openssl smime -decrypt -in mail.msg -inkey private.pem
hitb&lt;span style="color:#f92672">{&lt;/span>0b21cc2025534dbd2965390d2bcef45d&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The sources are available
&lt;a href="hitb2015-crypto300.tar.gz">here&lt;/a>&lt;/p></description></item><item><title>HITB 2015 Write-up - Crypto 400</title><link>/post/writeup-hitb2015-crypto400/</link><pubDate>Tue, 03 Nov 2015 00:00:00 +0100</pubDate><guid>/post/writeup-hitb2015-crypto400/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>The crypto 400 challenge deals with the Even Mansour cryptosystem. To validate this challenge we have to send the flag to a server.
The server checks if the answer matches the flag by encrypting the flag and the given message with a &lt;strong>random&lt;/strong> key.
If both are equal the flag is correct otherwise it fails and the encrypted message is printed.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">key &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>urandom(&lt;span style="color:#ae81ff">32&lt;/span>)
enc_flag &lt;span style="color:#f92672">=&lt;/span> encrypt(flag, key)
enc &lt;span style="color:#f92672">=&lt;/span> encrypt(answer, key)
&lt;span style="color:#66d9ef">if&lt;/span> enc &lt;span style="color:#f92672">==&lt;/span> enc_flag:
response &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;You lucky bastard, &lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74"> is indeed the correct flag!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> flag
&lt;span style="color:#66d9ef">else&lt;/span>:
response &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unfortunately that is not our flag :(&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
response &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Your guess encrypts as&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> enc
response &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;whereas our flag encrypts as&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> enc_flag
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="even-mansour-scheme">Even Mansour scheme&lt;/h2>
&lt;p>In this Even-Masour scheme the size of a block is 16-bytes and the key &amp;mdash; on 32-bytes &amp;mdash; is split in two: $k_1$ and $k_2$ each one on 16-bytes.
At first, the message $M$ is xor-ed with $k_1$ then $M \oplus k_1$ is going through a $F$ function which
will be discussed later. Finally the output is xor-ed with $k_2$.&lt;/p>
&lt;p>&lt;img src="evenmansour.png" alt="">&lt;/p>
&lt;p>So we have:&lt;/p>
&lt;p>$$C = F(M \oplus k_1) \oplus k_2$$&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">EvenMansour&lt;/span>(block, key):
block &lt;span style="color:#f92672">=&lt;/span> xor(block, key[:&lt;span style="color:#ae81ff">16&lt;/span>])
block &lt;span style="color:#f92672">=&lt;/span> F(block)
block &lt;span style="color:#f92672">=&lt;/span> xor(block, key[&lt;span style="color:#ae81ff">16&lt;/span>:])
&lt;span style="color:#66d9ef">return&lt;/span> block
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this challenge, the weakness comes from the $F$ function.&lt;/p>
&lt;h2 id="f-function">$F$ function&lt;/h2>
&lt;p>The $F$ function is composed of 64-rounds that perform the &lt;code>step(...)&lt;/code> transformation:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">F&lt;/span>(block):
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">64&lt;/span>):
block &lt;span style="color:#f92672">=&lt;/span> step(block)
&lt;span style="color:#66d9ef">return&lt;/span> block
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>step&lt;/code> uses a S-Box to transform the block in this way:&lt;/p>
&lt;p>&lt;img src="/img/step.png" alt="">&lt;/p>
&lt;p>$\begin{cases}
\text{block}^{n+1}_0 = \text{SBox}(\text{block}^{n}_{10} \oplus \text{block}^{n}_{12} \oplus \text{block}^{n}_{13} \oplus \text{block}^{n+1}_{15}) &amp;amp; k = 0 \\\&lt;br>
\text{block}^{n+1}_k = \text{block}^{n}_{k - 1} &amp;amp; k &amp;gt; 0
\end{cases}$&lt;/p>
&lt;p>$\text{block}^{n}_k$ is the byte $k$ of the &lt;em>block&lt;/em> at round $n$ ($0 \leq k &amp;lt; 16$ and $0 \leq n &amp;lt; 64$)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">step&lt;/span>(block):
&lt;span style="color:#66d9ef">return&lt;/span> chr( S[ ord(block[&lt;span style="color:#ae81ff">10&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(block[&lt;span style="color:#ae81ff">12&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(block[&lt;span style="color:#ae81ff">13&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(block[&lt;span style="color:#ae81ff">15&lt;/span>]) ] ) &lt;span style="color:#f92672">+&lt;/span> block[:&lt;span style="color:#ae81ff">15&lt;/span>]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>By ploting $y = \text{S-Box}(x)$ we can notice that the S-Box has a special construction:&lt;/p>
&lt;p>&lt;img src="/img/figure_1-1.png" alt="">&lt;/p>
&lt;p>I thought about computing the differential characteristics which is the probability that given the input difference
$\Delta = x \oplus y$ we get the output delta: $\delta = S(x) \oplus S(y)$.
We will call this probability $P(\Delta | \delta)$ and with
following function, we can compute this probability:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">P&lt;/span>(dx ,dy):
count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> x &lt;span style="color:#f92672">in&lt;/span> range(len(SBox)):
dY &lt;span style="color:#f92672">=&lt;/span> SBox[x] &lt;span style="color:#f92672">^&lt;/span> SBox[x &lt;span style="color:#f92672">^&lt;/span> dx]
&lt;span style="color:#66d9ef">if&lt;/span> dY &lt;span style="color:#f92672">==&lt;/span> dy:
count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> float(count) &lt;span style="color:#f92672">/&lt;/span> float(&lt;span style="color:#ae81ff">256&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>For all $\Delta$ and $\delta$, we notice that this probability is either 0 or 1. Consequently if we know $\delta$ we are sure to find $\Delta$. This will be useful for the differential attack.&lt;/p>
&lt;h2 id="differential-attack">Differential Attack&lt;/h2>
&lt;p>To find the flag, we will perform a differential attack. We have a message $M_1$ that we know and we have an unknown second message $M_2$
that is the flag. We also know $C_1$ and $C_2$ such as:&lt;/p>
&lt;p>$$\begin{eqnarray}
C_1 &amp;amp; = &amp;amp; F(M_1 \oplus k_1) \oplus k_2 \\\&lt;br>
C_2 &amp;amp; = &amp;amp; F(M_2 \oplus k_1) \oplus k_2
\end{eqnarray}$$&lt;/p>
&lt;p>&lt;img src="diff.png" alt="">&lt;/p>
&lt;p>By xor-ing $C_1$ and $C_2$ we can get $\Delta W = W_1 \oplus W_2 = C_1 \oplus C_2$. If somehow we can resolve $\Delta V$:&lt;/p>
&lt;p>$$\begin{eqnarray}
\Delta V &amp;amp; = &amp;amp; V_1 \oplus V_2 \\\&lt;br>
&amp;amp; = &amp;amp; M_1 \oplus k_1 \oplus M_2 \oplus k_1\\\&lt;br>
&amp;amp; = &amp;amp; M_1 \oplus M_2.
\end{eqnarray}$$&lt;/p>
&lt;p>We can extract $M_2$ with:&lt;/p>
&lt;p>$$M_2 = \Delta V \oplus M_1$$&lt;/p>
&lt;h2 id="recovering-delta-v">Recovering $\Delta V$&lt;/h2>
&lt;p>Now, let&amp;rsquo;s see how to resolve $\Delta V$ from $\Delta W$.&lt;/p>
&lt;p>From the &lt;code>step&lt;/code> function, we know that $\text{block}^{n+1}_k = \text{block}^{n}_{k - 1}$ therefore:&lt;/p>
&lt;p>$$\Delta W^{n-1}_k = \Delta W^{n}_{k + 1} \forall k &amp;lt; 15$$&lt;/p>
&lt;p>We know also $\Delta W^{n-1}_{0,1,2 \ldots 14}$ but not $\Delta W^{n-1}_{15}$&lt;/p>
&lt;p>To find $\Delta W^{n-1}_{15}$ we will use the fact that $P(\Delta X | \Delta W^{n-1}_{15}) = 1$ for a given $\Delta X$.
Concretely, I built a table &lt;em>diffTable&lt;/em> which maps $\delta$ to $\Delta$.&lt;/p>
&lt;p>$\begin{eqnarray}
\text{diffTable}(\Delta W^{n}_{0}) &amp;amp; = &amp;amp; \Delta W^{n-1}_{10} \oplus \Delta W^{n-1}_{12} \oplus \Delta W^{n-1}_{13} \oplus \Delta W^{n-1}_{15} \\\&lt;br>
&amp;amp; = &amp;amp; \Delta W^{n}_{11} \oplus \Delta W^{n}_{13} \oplus \Delta W^{n}_{14} \oplus \Delta W^{n-1}_{15}\\\&lt;br>
\Delta W^{n-1}_{15} &amp;amp; = &amp;amp; \text{diffTable}(\Delta W^{n}_{0}) \oplus \Delta W^{n}_{11} \oplus \Delta W^{n}_{13} \oplus \Delta W^{n}_{14}
\end{eqnarray}$&lt;/p>
&lt;p>Which enables to recover $\Delta W^{n - 1}$ from $\Delta W^{n}$.
Then, with recursion we can compute $\Delta W^{0} = \Delta V$&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>The following script is the implementation of the attack:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/python2.7&lt;/span>
&lt;span style="color:#75715e"># -*- coding: utf-8 -*-&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> os
S &lt;span style="color:#f92672">=&lt;/span> [
&lt;span style="color:#ae81ff">0xa5&lt;/span>,&lt;span style="color:#ae81ff">0xc6&lt;/span>,&lt;span style="color:#ae81ff">0x62&lt;/span>,&lt;span style="color:#ae81ff">0x01&lt;/span>,&lt;span style="color:#ae81ff">0x49&lt;/span>,&lt;span style="color:#ae81ff">0x2a&lt;/span>,&lt;span style="color:#ae81ff">0x8e&lt;/span>,&lt;span style="color:#ae81ff">0xed&lt;/span>,&lt;span style="color:#ae81ff">0x1f&lt;/span>,&lt;span style="color:#ae81ff">0x7c&lt;/span>,&lt;span style="color:#ae81ff">0xd8&lt;/span>,&lt;span style="color:#ae81ff">0xbb&lt;/span>,&lt;span style="color:#ae81ff">0xf3&lt;/span>,&lt;span style="color:#ae81ff">0x90&lt;/span>,&lt;span style="color:#ae81ff">0x34&lt;/span>,&lt;span style="color:#ae81ff">0x57&lt;/span>,
&lt;span style="color:#ae81ff">0xb3&lt;/span>,&lt;span style="color:#ae81ff">0xd0&lt;/span>,&lt;span style="color:#ae81ff">0x74&lt;/span>,&lt;span style="color:#ae81ff">0x17&lt;/span>,&lt;span style="color:#ae81ff">0x5f&lt;/span>,&lt;span style="color:#ae81ff">0x3c&lt;/span>,&lt;span style="color:#ae81ff">0x98&lt;/span>,&lt;span style="color:#ae81ff">0xfb&lt;/span>,&lt;span style="color:#ae81ff">0x09&lt;/span>,&lt;span style="color:#ae81ff">0x6a&lt;/span>,&lt;span style="color:#ae81ff">0xce&lt;/span>,&lt;span style="color:#ae81ff">0xad&lt;/span>,&lt;span style="color:#ae81ff">0xe5&lt;/span>,&lt;span style="color:#ae81ff">0x86&lt;/span>,&lt;span style="color:#ae81ff">0x22&lt;/span>,&lt;span style="color:#ae81ff">0x41&lt;/span>,
&lt;span style="color:#ae81ff">0x89&lt;/span>,&lt;span style="color:#ae81ff">0xea&lt;/span>,&lt;span style="color:#ae81ff">0x4e&lt;/span>,&lt;span style="color:#ae81ff">0x2d&lt;/span>,&lt;span style="color:#ae81ff">0x65&lt;/span>,&lt;span style="color:#ae81ff">0x06&lt;/span>,&lt;span style="color:#ae81ff">0xa2&lt;/span>,&lt;span style="color:#ae81ff">0xc1&lt;/span>,&lt;span style="color:#ae81ff">0x33&lt;/span>,&lt;span style="color:#ae81ff">0x50&lt;/span>,&lt;span style="color:#ae81ff">0xf4&lt;/span>,&lt;span style="color:#ae81ff">0x97&lt;/span>,&lt;span style="color:#ae81ff">0xdf&lt;/span>,&lt;span style="color:#ae81ff">0xbc&lt;/span>,&lt;span style="color:#ae81ff">0x18&lt;/span>,&lt;span style="color:#ae81ff">0x7b&lt;/span>,
&lt;span style="color:#ae81ff">0x9f&lt;/span>,&lt;span style="color:#ae81ff">0xfc&lt;/span>,&lt;span style="color:#ae81ff">0x58&lt;/span>,&lt;span style="color:#ae81ff">0x3b&lt;/span>,&lt;span style="color:#ae81ff">0x73&lt;/span>,&lt;span style="color:#ae81ff">0x10&lt;/span>,&lt;span style="color:#ae81ff">0xb4&lt;/span>,&lt;span style="color:#ae81ff">0xd7&lt;/span>,&lt;span style="color:#ae81ff">0x25&lt;/span>,&lt;span style="color:#ae81ff">0x46&lt;/span>,&lt;span style="color:#ae81ff">0xe2&lt;/span>,&lt;span style="color:#ae81ff">0x81&lt;/span>,&lt;span style="color:#ae81ff">0xc9&lt;/span>,&lt;span style="color:#ae81ff">0xaa&lt;/span>,&lt;span style="color:#ae81ff">0x0e&lt;/span>,&lt;span style="color:#ae81ff">0x6d&lt;/span>,
&lt;span style="color:#ae81ff">0xfd&lt;/span>,&lt;span style="color:#ae81ff">0x9e&lt;/span>,&lt;span style="color:#ae81ff">0x3a&lt;/span>,&lt;span style="color:#ae81ff">0x59&lt;/span>,&lt;span style="color:#ae81ff">0x11&lt;/span>,&lt;span style="color:#ae81ff">0x72&lt;/span>,&lt;span style="color:#ae81ff">0xd6&lt;/span>,&lt;span style="color:#ae81ff">0xb5&lt;/span>,&lt;span style="color:#ae81ff">0x47&lt;/span>,&lt;span style="color:#ae81ff">0x24&lt;/span>,&lt;span style="color:#ae81ff">0x80&lt;/span>,&lt;span style="color:#ae81ff">0xe3&lt;/span>,&lt;span style="color:#ae81ff">0xab&lt;/span>,&lt;span style="color:#ae81ff">0xc8&lt;/span>,&lt;span style="color:#ae81ff">0x6c&lt;/span>,&lt;span style="color:#ae81ff">0x0f&lt;/span>,
&lt;span style="color:#ae81ff">0xeb&lt;/span>,&lt;span style="color:#ae81ff">0x88&lt;/span>,&lt;span style="color:#ae81ff">0x2c&lt;/span>,&lt;span style="color:#ae81ff">0x4f&lt;/span>,&lt;span style="color:#ae81ff">0x07&lt;/span>,&lt;span style="color:#ae81ff">0x64&lt;/span>,&lt;span style="color:#ae81ff">0xc0&lt;/span>,&lt;span style="color:#ae81ff">0xa3&lt;/span>,&lt;span style="color:#ae81ff">0x51&lt;/span>,&lt;span style="color:#ae81ff">0x32&lt;/span>,&lt;span style="color:#ae81ff">0x96&lt;/span>,&lt;span style="color:#ae81ff">0xf5&lt;/span>,&lt;span style="color:#ae81ff">0xbd&lt;/span>,&lt;span style="color:#ae81ff">0xde&lt;/span>,&lt;span style="color:#ae81ff">0x7a&lt;/span>,&lt;span style="color:#ae81ff">0x19&lt;/span>,
&lt;span style="color:#ae81ff">0xd1&lt;/span>,&lt;span style="color:#ae81ff">0xb2&lt;/span>,&lt;span style="color:#ae81ff">0x16&lt;/span>,&lt;span style="color:#ae81ff">0x75&lt;/span>,&lt;span style="color:#ae81ff">0x3d&lt;/span>,&lt;span style="color:#ae81ff">0x5e&lt;/span>,&lt;span style="color:#ae81ff">0xfa&lt;/span>,&lt;span style="color:#ae81ff">0x99&lt;/span>,&lt;span style="color:#ae81ff">0x6b&lt;/span>,&lt;span style="color:#ae81ff">0x08&lt;/span>,&lt;span style="color:#ae81ff">0xac&lt;/span>,&lt;span style="color:#ae81ff">0xcf&lt;/span>,&lt;span style="color:#ae81ff">0x87&lt;/span>,&lt;span style="color:#ae81ff">0xe4&lt;/span>,&lt;span style="color:#ae81ff">0x40&lt;/span>,&lt;span style="color:#ae81ff">0x23&lt;/span>,
&lt;span style="color:#ae81ff">0xc7&lt;/span>,&lt;span style="color:#ae81ff">0xa4&lt;/span>,&lt;span style="color:#ae81ff">0x00&lt;/span>,&lt;span style="color:#ae81ff">0x63&lt;/span>,&lt;span style="color:#ae81ff">0x2b&lt;/span>,&lt;span style="color:#ae81ff">0x48&lt;/span>,&lt;span style="color:#ae81ff">0xec&lt;/span>,&lt;span style="color:#ae81ff">0x8f&lt;/span>,&lt;span style="color:#ae81ff">0x7d&lt;/span>,&lt;span style="color:#ae81ff">0x1e&lt;/span>,&lt;span style="color:#ae81ff">0xba&lt;/span>,&lt;span style="color:#ae81ff">0xd9&lt;/span>,&lt;span style="color:#ae81ff">0x91&lt;/span>,&lt;span style="color:#ae81ff">0xf2&lt;/span>,&lt;span style="color:#ae81ff">0x56&lt;/span>,&lt;span style="color:#ae81ff">0x35&lt;/span>,
&lt;span style="color:#ae81ff">0x14&lt;/span>,&lt;span style="color:#ae81ff">0x77&lt;/span>,&lt;span style="color:#ae81ff">0xd3&lt;/span>,&lt;span style="color:#ae81ff">0xb0&lt;/span>,&lt;span style="color:#ae81ff">0xf8&lt;/span>,&lt;span style="color:#ae81ff">0x9b&lt;/span>,&lt;span style="color:#ae81ff">0x3f&lt;/span>,&lt;span style="color:#ae81ff">0x5c&lt;/span>,&lt;span style="color:#ae81ff">0xae&lt;/span>,&lt;span style="color:#ae81ff">0xcd&lt;/span>,&lt;span style="color:#ae81ff">0x69&lt;/span>,&lt;span style="color:#ae81ff">0x0a&lt;/span>,&lt;span style="color:#ae81ff">0x42&lt;/span>,&lt;span style="color:#ae81ff">0x21&lt;/span>,&lt;span style="color:#ae81ff">0x85&lt;/span>,&lt;span style="color:#ae81ff">0xe6&lt;/span>,
&lt;span style="color:#ae81ff">0x02&lt;/span>,&lt;span style="color:#ae81ff">0x61&lt;/span>,&lt;span style="color:#ae81ff">0xc5&lt;/span>,&lt;span style="color:#ae81ff">0xa6&lt;/span>,&lt;span style="color:#ae81ff">0xee&lt;/span>,&lt;span style="color:#ae81ff">0x8d&lt;/span>,&lt;span style="color:#ae81ff">0x29&lt;/span>,&lt;span style="color:#ae81ff">0x4a&lt;/span>,&lt;span style="color:#ae81ff">0xb8&lt;/span>,&lt;span style="color:#ae81ff">0xdb&lt;/span>,&lt;span style="color:#ae81ff">0x7f&lt;/span>,&lt;span style="color:#ae81ff">0x1c&lt;/span>,&lt;span style="color:#ae81ff">0x54&lt;/span>,&lt;span style="color:#ae81ff">0x37&lt;/span>,&lt;span style="color:#ae81ff">0x93&lt;/span>,&lt;span style="color:#ae81ff">0xf0&lt;/span>,
&lt;span style="color:#ae81ff">0x38&lt;/span>,&lt;span style="color:#ae81ff">0x5b&lt;/span>,&lt;span style="color:#ae81ff">0xff&lt;/span>,&lt;span style="color:#ae81ff">0x9c&lt;/span>,&lt;span style="color:#ae81ff">0xd4&lt;/span>,&lt;span style="color:#ae81ff">0xb7&lt;/span>,&lt;span style="color:#ae81ff">0x13&lt;/span>,&lt;span style="color:#ae81ff">0x70&lt;/span>,&lt;span style="color:#ae81ff">0x82&lt;/span>,&lt;span style="color:#ae81ff">0xe1&lt;/span>,&lt;span style="color:#ae81ff">0x45&lt;/span>,&lt;span style="color:#ae81ff">0x26&lt;/span>,&lt;span style="color:#ae81ff">0x6e&lt;/span>,&lt;span style="color:#ae81ff">0x0d&lt;/span>,&lt;span style="color:#ae81ff">0xa9&lt;/span>,&lt;span style="color:#ae81ff">0xca&lt;/span>,
&lt;span style="color:#ae81ff">0x2e&lt;/span>,&lt;span style="color:#ae81ff">0x4d&lt;/span>,&lt;span style="color:#ae81ff">0xe9&lt;/span>,&lt;span style="color:#ae81ff">0x8a&lt;/span>,&lt;span style="color:#ae81ff">0xc2&lt;/span>,&lt;span style="color:#ae81ff">0xa1&lt;/span>,&lt;span style="color:#ae81ff">0x05&lt;/span>,&lt;span style="color:#ae81ff">0x66&lt;/span>,&lt;span style="color:#ae81ff">0x94&lt;/span>,&lt;span style="color:#ae81ff">0xf7&lt;/span>,&lt;span style="color:#ae81ff">0x53&lt;/span>,&lt;span style="color:#ae81ff">0x30&lt;/span>,&lt;span style="color:#ae81ff">0x78&lt;/span>,&lt;span style="color:#ae81ff">0x1b&lt;/span>,&lt;span style="color:#ae81ff">0xbf&lt;/span>,&lt;span style="color:#ae81ff">0xdc&lt;/span>,
&lt;span style="color:#ae81ff">0x4c&lt;/span>,&lt;span style="color:#ae81ff">0x2f&lt;/span>,&lt;span style="color:#ae81ff">0x8b&lt;/span>,&lt;span style="color:#ae81ff">0xe8&lt;/span>,&lt;span style="color:#ae81ff">0xa0&lt;/span>,&lt;span style="color:#ae81ff">0xc3&lt;/span>,&lt;span style="color:#ae81ff">0x67&lt;/span>,&lt;span style="color:#ae81ff">0x04&lt;/span>,&lt;span style="color:#ae81ff">0xf6&lt;/span>,&lt;span style="color:#ae81ff">0x95&lt;/span>,&lt;span style="color:#ae81ff">0x31&lt;/span>,&lt;span style="color:#ae81ff">0x52&lt;/span>,&lt;span style="color:#ae81ff">0x1a&lt;/span>,&lt;span style="color:#ae81ff">0x79&lt;/span>,&lt;span style="color:#ae81ff">0xdd&lt;/span>,&lt;span style="color:#ae81ff">0xbe&lt;/span>,
&lt;span style="color:#ae81ff">0x5a&lt;/span>,&lt;span style="color:#ae81ff">0x39&lt;/span>,&lt;span style="color:#ae81ff">0x9d&lt;/span>,&lt;span style="color:#ae81ff">0xfe&lt;/span>,&lt;span style="color:#ae81ff">0xb6&lt;/span>,&lt;span style="color:#ae81ff">0xd5&lt;/span>,&lt;span style="color:#ae81ff">0x71&lt;/span>,&lt;span style="color:#ae81ff">0x12&lt;/span>,&lt;span style="color:#ae81ff">0xe0&lt;/span>,&lt;span style="color:#ae81ff">0x83&lt;/span>,&lt;span style="color:#ae81ff">0x27&lt;/span>,&lt;span style="color:#ae81ff">0x44&lt;/span>,&lt;span style="color:#ae81ff">0x0c&lt;/span>,&lt;span style="color:#ae81ff">0x6f&lt;/span>,&lt;span style="color:#ae81ff">0xcb&lt;/span>,&lt;span style="color:#ae81ff">0xa8&lt;/span>,
&lt;span style="color:#ae81ff">0x60&lt;/span>,&lt;span style="color:#ae81ff">0x03&lt;/span>,&lt;span style="color:#ae81ff">0xa7&lt;/span>,&lt;span style="color:#ae81ff">0xc4&lt;/span>,&lt;span style="color:#ae81ff">0x8c&lt;/span>,&lt;span style="color:#ae81ff">0xef&lt;/span>,&lt;span style="color:#ae81ff">0x4b&lt;/span>,&lt;span style="color:#ae81ff">0x28&lt;/span>,&lt;span style="color:#ae81ff">0xda&lt;/span>,&lt;span style="color:#ae81ff">0xb9&lt;/span>,&lt;span style="color:#ae81ff">0x1d&lt;/span>,&lt;span style="color:#ae81ff">0x7e&lt;/span>,&lt;span style="color:#ae81ff">0x36&lt;/span>,&lt;span style="color:#ae81ff">0x55&lt;/span>,&lt;span style="color:#ae81ff">0xf1&lt;/span>,&lt;span style="color:#ae81ff">0x92&lt;/span>,
&lt;span style="color:#ae81ff">0x76&lt;/span>,&lt;span style="color:#ae81ff">0x15&lt;/span>,&lt;span style="color:#ae81ff">0xb1&lt;/span>,&lt;span style="color:#ae81ff">0xd2&lt;/span>,&lt;span style="color:#ae81ff">0x9a&lt;/span>,&lt;span style="color:#ae81ff">0xf9&lt;/span>,&lt;span style="color:#ae81ff">0x5d&lt;/span>,&lt;span style="color:#ae81ff">0x3e&lt;/span>,&lt;span style="color:#ae81ff">0xcc&lt;/span>,&lt;span style="color:#ae81ff">0xaf&lt;/span>,&lt;span style="color:#ae81ff">0x0b&lt;/span>,&lt;span style="color:#ae81ff">0x68&lt;/span>,&lt;span style="color:#ae81ff">0x20&lt;/span>,&lt;span style="color:#ae81ff">0x43&lt;/span>,&lt;span style="color:#ae81ff">0xe7&lt;/span>,&lt;span style="color:#ae81ff">0x84&lt;/span>
]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">xor&lt;/span>(block1, block2):
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join( chr(ord(a) &lt;span style="color:#f92672">^&lt;/span> ord(b)) &lt;span style="color:#66d9ef">for&lt;/span> (a,b) &lt;span style="color:#f92672">in&lt;/span> zip(block1, block2))
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">step&lt;/span>(block):
&lt;span style="color:#66d9ef">return&lt;/span> chr(S[ord(block[&lt;span style="color:#ae81ff">10&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(block[&lt;span style="color:#ae81ff">12&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(block[&lt;span style="color:#ae81ff">13&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(block[&lt;span style="color:#ae81ff">15&lt;/span>])]) &lt;span style="color:#f92672">+&lt;/span> block[:&lt;span style="color:#ae81ff">15&lt;/span>]
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">F&lt;/span>(block):
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> xrange(&lt;span style="color:#ae81ff">64&lt;/span>):
block &lt;span style="color:#f92672">=&lt;/span> step(block)
&lt;span style="color:#66d9ef">return&lt;/span> block
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">EvenMansour&lt;/span>(block, key):
block &lt;span style="color:#f92672">=&lt;/span> xor(block, key[:&lt;span style="color:#ae81ff">16&lt;/span>])
block &lt;span style="color:#f92672">=&lt;/span> F(block)
block &lt;span style="color:#f92672">=&lt;/span> xor(block, key[&lt;span style="color:#ae81ff">16&lt;/span>:])
&lt;span style="color:#66d9ef">return&lt;/span> block
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">encrypt&lt;/span>(data, key):
data, num_blocks &lt;span style="color:#f92672">=&lt;/span> pad(data)
res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> xrange(num_blocks):
block &lt;span style="color:#f92672">=&lt;/span> EvenMansour(data[&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">*&lt;/span>i:&lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#f92672">*&lt;/span>i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">16&lt;/span>], key)
res &lt;span style="color:#f92672">+=&lt;/span> block
&lt;span style="color:#66d9ef">return&lt;/span> res
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">pad&lt;/span>(data):
&lt;span style="color:#66d9ef">while&lt;/span> True:
data &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> len(data) &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;span style="color:#66d9ef">return&lt;/span> data, len(data) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
&lt;span style="color:#75715e">#&lt;/span>
&lt;span style="color:#75715e"># Table T[a] = b such as&lt;/span>
&lt;span style="color:#75715e"># S[x] ^ S[y] = a and b = x ^ y&lt;/span>
&lt;span style="color:#75715e">#&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">DiffTable&lt;/span>(S):
table &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(len(S))]
&lt;span style="color:#66d9ef">for&lt;/span> delta &lt;span style="color:#f92672">in&lt;/span> range(len(S)):
&lt;span style="color:#66d9ef">for&lt;/span> x &lt;span style="color:#f92672">in&lt;/span> range(len(S)):
dY &lt;span style="color:#f92672">=&lt;/span> S[x] &lt;span style="color:#f92672">^&lt;/span> S[x &lt;span style="color:#f92672">^&lt;/span> delta]
table[dY] &lt;span style="color:#f92672">=&lt;/span> delta
&lt;span style="color:#66d9ef">return&lt;/span> table
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>():
key &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>urandom(&lt;span style="color:#ae81ff">32&lt;/span>)
M1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hitb{0123456789abcdef}&amp;#34;&lt;/span>
M2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;aaaaaaaaaaaaaaaaaaaaaa&amp;#34;&lt;/span>
C1 &lt;span style="color:#f92672">=&lt;/span> encrypt(M1, key)
C2 &lt;span style="color:#f92672">=&lt;/span> encrypt(M2, key)
numberOfBlocks &lt;span style="color:#f92672">=&lt;/span> len(C2) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>
diffTable &lt;span style="color:#f92672">=&lt;/span> DiffTable(S)
clearText &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> block &lt;span style="color:#f92672">in&lt;/span> range(numberOfBlocks):
dW &lt;span style="color:#f92672">=&lt;/span> xor(C1,C2)[&lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#f92672">*&lt;/span> block : &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (block &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)]
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">64&lt;/span>):
dWtemp &lt;span style="color:#f92672">=&lt;/span> [dW[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">15&lt;/span>)]
delta &lt;span style="color:#f92672">=&lt;/span> diffTable[ord(dW[&lt;span style="color:#ae81ff">0&lt;/span>])]
dW15 &lt;span style="color:#f92672">=&lt;/span> chr(ord(dW[&lt;span style="color:#ae81ff">11&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(dW[&lt;span style="color:#ae81ff">13&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> ord(dW[&lt;span style="color:#ae81ff">14&lt;/span>]) &lt;span style="color:#f92672">^&lt;/span> delta)
dWtemp&lt;span style="color:#f92672">.&lt;/span>append(dW15)
dW &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(dWtemp)
M &lt;span style="color:#f92672">=&lt;/span> xor(dW, M2[&lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#f92672">*&lt;/span> block : &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (block &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)])
clearText &lt;span style="color:#f92672">+=&lt;/span> M
&lt;span style="color:#66d9ef">print&lt;/span> clearText
&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
main()
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>In fact by noticing that&lt;/p>
&lt;p>$$F(x \oplus y) = F(x) \oplus F(y) \oplus C^{te}$$&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">for&lt;/span> b &lt;span style="color:#f92672">in&lt;/span> xrange(&lt;span style="color:#ae81ff">10&lt;/span>):
u &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>urandom(&lt;span style="color:#ae81ff">16&lt;/span>);
v &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>urandom(&lt;span style="color:#ae81ff">16&lt;/span>);
d &lt;span style="color:#f92672">=&lt;/span> xor(F(xor(u,v)), xor(F(u), F(v)))
&lt;span style="color:#66d9ef">print&lt;/span> d&lt;span style="color:#f92672">.&lt;/span>encode(&lt;span style="color:#e6db74">&amp;#34;hex&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We have:&lt;/p>
&lt;p>\begin{eqnarray}
F(M_1 \oplus k_1) \oplus F(M_2 \oplus k_1) &amp;amp; = &amp;amp; F(M_1) \oplus F(M_2)\&lt;br>
M_2 &amp;amp; = &amp;amp; F^{-1}(F(M_1) \oplus C_1 \oplus C_2)
\end{eqnarray}&lt;/p>
&lt;p>Which is far more easier to resolve.&lt;/p>
&lt;p>Thanks to &lt;strong>jb^&lt;/strong> who help me and who find the previous technique.&lt;/p>
&lt;p>Sources are available
&lt;a href="hitb2015-crypto400.tar.gz">here&lt;/a>&lt;/p></description></item></channel></rss>